/*-------------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported from C# to Java by Wolfgang Ahorner
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
------------------------------------------------------------------------*/
-->begin

class Parser {
-->constants
	inline static var T:Bool = true;
	inline static var x:Bool = false;
	static var minErrDist:Int = 2;

	public var t:Token;    // last recognized token
	public var la:Token;   // lookahead token
	var errDist:Int;
	
	public var scanner:Scanner;
	public var errors:Errors;

	-->declarations

	public function new(scanner:Scanner) {
		errDist = minErrDist;
		this.scanner = scanner;
		errors = new Errors();
	}

	function SynErr (n:Int):Void {
		if (errDist >= minErrDist) errors.SynErr(la.line, la.col, n);
		errDist = 0;
	}

	public function SemErr (msg:String):Void {
		if (errDist >= minErrDist) errors.SemErr(t.line, t.col, msg);
		errDist = 0;
	}
	
	function Get ():Void {
		while (true) {
			t = la;
			la = scanner.Scan();
			if (la.kind <= maxT) {
				++errDist;
				break;
			}
-->pragmas
			la = t;
		}
	}
	
	function Expect (n:Int):Void {
		if (la.kind==n) Get(); else { SynErr(n); }
	}
	
	function StartOf (s:Int):Bool {
		return set[s][la.kind];
	}
	
	function ExpectWeak (n:Int, follow:Int):Void {
		if (la.kind == n) Get();
		else {
			SynErr(n);
			while (!StartOf(follow)) Get();
		}
	}
	
	function WeakSeparator (n:Int, syFol:Int, repFol:Int):Bool {
		var kind:Int = la.kind;
		if (kind == n) { Get(); return true; }
		else if (StartOf(repFol)) return false;
		else {
			SynErr(n);
			while (!(set[syFol][kind] || set[repFol][kind] || set[0][kind])) {
				Get();
				kind = la.kind;
			}
			return StartOf(syFol);
		}
	}
	
-->productions

	public function Parse():Void {
		la = new Token();
		la.val = "";		
		Get();
-->parseRoot
		Expect(0);
	}

	private static var set:Array<Array<Bool>> = [
-->initialization
	];
} // end Parser


class Errors {
	public var count:Int;                                    // number of errors detected
//	public java.io.PrintStream errorStream = System.out;     // error messages go to this stream
	static var errMsgFormat:String = "-- line {0} col {1}: {2}"; // 0=line, 1=column, 2=text
	
	public function new() {
		count = 0;
	}
	
	public function printMsg(line:Int, column:Int, msg:String):Void {
		var b:String = errMsgFormat;
		b = StringTools.replace(b, '{0}', Std.string(line));
		b = StringTools.replace(b, '{1}', Std.string(column));
		b = StringTools.replace(b, '{2}', msg);
		trace(b);
	}
	
	public function SynErr (line:Int, col:Int, n:Int):Void {
		var s:String;
		switch (n) {-->errors
			default: s = "error " + n;
		}
		printMsg(line, col, s);
		count++;
		throw new FatalError(s);
	}

	public function SemErr (?line:Int, ?col:Int, s:String):Void {
		line == null ? printMsg(line, col, s) : trace(s);
		count++;
		throw new FatalError(s);
	}
	
	public function Warning (?line:Int, ?col:Int, s:String):Void {	
		line == null ? printMsg(line, col, s): trace(s);
	}
} // Errors

class FatalError {
	public var message:String;
	public static var serialVersionUID:Float = 1.0;
	public function new(s:String) { this.message = s; }
}

/*------------------------- modifier handling -----------------------------*/

  class Modifier {
    static public var _public:Int       = 0x0001;
    static public var _private:Int      = 0x0002;
    static public var _protected:Int    = 0x0004;
    static public var _static:Int       = 0x0008;
    static public var _final:Int        = 0x0010;
    static public var _synchronized:Int = 0x0020;
    static public var _volatile:Int     = 0x0040;
    static public var _transient:Int    = 0x0080;
    static public var _native:Int       = 0x0100;
    static public var _abstract:Int     = 0x0400;
    static public var _strictfp:Int     = 0x0800;

  /* sets of modifiers that can be attached to certain program elements    *
   * e.g., "constants" marks all modifiers that may be used with constants */
    static public var none:Int         = 0x0000;
    static public var access:Int       = _public | _protected | _private;    // 0x0007
    static public var classes:Int      = access | _abstract | _static | _final | _strictfp;    // 0x0c1f
    static public var fields:Int       = access | _static | _final | _transient | _volatile;  // 0x00df
    static public var methods:Int      = access | _abstract | _static | _final | _synchronized | _native | _strictfp; // 0x0d3f
    static public var constructors:Int = access; // 0x0007
    static public var interfaces:Int   = access | _abstract | _static | _strictfp; // 0x0c0f
    static public var constants:Int    = _public | _static | _final; // 0x0019
    static public var all:Int          = 0x0dff;
  }
  
  class Modifiers {
    private var cur:Int;
    private var parser:Parser;

 	public function new(parser:Parser) {
		cur = 0;
 		this.parser = parser;
        }

    public function add (m:Int):Void {
      if ((cur & m) == 0) cur |= m;
      else parser.error("repeated modifier");
    }
    
    public function check(allowed:Int):Void {
      var wrong:Int = cur & (allowed ^ Modifier.all);
      if (wrong != Modifier.none)
        parser.error("modifier(s) " + toString(wrong) + "not allowed here");
      else
        checkAccess();
    }
    
    private function checkAccess():Void {
      var access:Int = cur & Modifier.access;
      if (access != Modifier.none && access != Modifier._public && 
          access != Modifier._protected && access != Modifier._private)
          parser.error("illegal combination of modifiers: " + toString(access));
    }
    
    private function toString(m:Int):String {
      var s:String = "";
      if ((m & Modifier._public) != 0) s += "public ";
      if ((m & Modifier._private) != 0) s += "private ";
      if ((m & Modifier._protected) != 0) s += "protected ";
      if ((m & Modifier._static) != 0) s += "static ";
      if ((m & Modifier._final) != 0) s += "final ";
      if ((m & Modifier._synchronized) != 0) s += "synchronized ";
      if ((m & Modifier._volatile) != 0) s += "volatile ";
      if ((m & Modifier._transient) != 0) s += "transient ";
      if ((m & Modifier._native) != 0) s += "native ";
      if ((m & Modifier._abstract) != 0) s += "abstract ";
      if ((m & Modifier._strictfp) != 0) s += "strictfp ";
      return s;
    }
  }

/*-------------------- expression handling ----------------------------------*/
  
class ExprKind
{
	static public var NONE:Int     =  0;
	static public var CONDEXPR:Int = 17;
	static public var APPLY:Int    = 25;
	static public var NEWCLASS:Int = 26;
	static public var NEWARRAY:Int = 27;
	static public var PARENS:Int   = 28;
	static public var ASSIGN:Int   = 29;
	static public var TYPECAST:Int = 30;
	static public var TYPETEST:Int = 31;
	static public var SELECT:Int   = 33;
	static public var IDENT:Int    = 34;
	static public var LITERAL:Int  = 35;
	static public var POS:Int      = 41;
	static public var NEG:Int      = 42;
	static public var NOT:Int      = 43;
	static public var COMPL:Int    = 44;
	static public var PREINC:Int   = 45;
	static public var PREDEC:Int   = 46;
	static public var POSTINC:Int  = 47;
	static public var POSTDEC:Int  = 48;
	static public var BINARY:Int   = 50;
}

class ExprInfo
{
	private var kind:Int;
	private var parser:Parser;
	
	public function new(parser:Parser) {
		kind = ExprKind.NONE;
  		this.parser = parser;
	}
    
	public function getKind():Int {
		return kind;
	}
    
	public function setKind(k:Int):Void {
		kind = k;
	}
    
	public function checkExprStat():Void {
		if ( kind != ExprKind.APPLY &&  kind != ExprKind.NEWCLASS && 
		   kind != ExprKind.ASSIGN && kind != ExprKind.PREINC &&
		   kind != ExprKind.PREDEC && kind != ExprKind.POSTINC &&
		   kind != ExprKind.POSTDEC)
		parser.error("not a statement" + " (" + kind + ")");
	}
}

class ExpressionBuilder
{
	private var parser:Parser;
	private var operators:Array<ParserOperator>;
	private var operands:Array<Expression>;
	
	public function new(parser:Parser) {
  		this.parser = parser;
		operators = [];
		operands = [];
	}
    
	public function generate():Expression {
		recursiveReduceExpression();
		return operands[0];
	}
	
	public function pushOperator(operator:ParserOperator)
	{
		recursiveReduceExpression(lookupOperatorPrecedence(operator));
		operators.push(operator);
	}
	
	public function pushOperand(operand:Expression)
	{
		operands.push(operator);
	}
    
	public function checkExpressionStatement():Void {
		var expression:Expression = generate();
		switch (generate())
		{
		    case ECallMethod():
		    case EClassInstantiation():
		    case EAssignment:
		    case EPrefix:
		    case EPostfix:
		    default:
			parser.error("not a statement" + " (" + generate() + ")");
		}
	}
	
	private function recursiveReduceExpression(?precedence:Int = 0):Void
	{
		while (operators.length > 0 && lookupOperatorPrecedence(operators[operators.length - 1]) >= precedence)
			reduceExpression();
	}

	private function reduceExpression():Void
	{
		// reduce topmost operator
		switch (operators.pop())
		{
		    case PConditional(thenExpression, elseExpression):
			// get conditional
			var conditional:Expression = operands.pop();
			operands.push(EConditional(conditional, thenExpression, elseExpression));
		
		    case PAssignment(operator):
			// get reference
			var value:Expression = operands.pop(), reference:Expression = operands.pop();
			// we can only assign to a reference
//[TODO] these might be redundant
//			if ((Type.enumConstructor(reference) != 'EReference') &&
//			    (Type.enumConstructor(reference) != 'EArrayAccess'))
//				throw tokenizer.createSyntaxError('Invalid assignment left-hand side.');

			// rewrite assignment operators as expressions
			if (operator != null)
				value = EOperation(operator, reference, value);
			// extract reference type
			switch (reference) {
			    case EReference(identifier, base): operands.push(EAssignment(identifier, base, value));
			    case EReference(index, base): operands.push(EArrayAssignment(index, base, value));
			    default: parser.error('invalid assignment left-hand side');
			}
		
		    case POperator(operator):
			switch (operator)
			{
			    // arity: 1
			    case OpNot, OpBitwiseNot, OpUnaryPlus, OpUnaryMinus:
				var a:Expression = operands.pop();
				operands.push(EOperation(operator, a));

			    // arity: 2
			    case OpOr, OpAnd, OpBitwiseOr, OpBitwiseXor, OpBitwiseAnd, OpEqual,
			      OpUnequal, OpLessThan, OpLessThanOrEqual, OpGreaterThan, OpGreaterThanOrEqual,
			      OpInstanceOf, OpLeftShift, OpRightShift, OpZeroRightShift, OpPlus, OpMinus,
			      OpMultiply, OpDivide, OpModulus:
				var b:Expression = operands.pop(), a:Expression = operands.pop();
				operands.push(EOperation(operator, a, b));
			}
	    
		    case PCast(type):
			// expression cast
			var expression:Expression = operands.pop();
			operands.push(ECast(type, expression));
		    
		    case PPrefix(type):
			// get reference
		        var reference:Expression = operands.pop();
			// we can only assign to a reference
//[TODO] these might be redundant
//			if ((Type.enumConstructor(reference) != 'EReference') &&
//			    (Type.enumConstructor(reference) != 'EArrayAccess'))
//				throw tokenizer.createSyntaxError('Invalid assignment left-hand side.');
				
			// compound prefix operation
			operands.push(EPrefix(reference, type));
		    
		    case PPostfix(type):
			// get reference
		        var reference:Expression = operands.pop();
			// we can only assign to a reference
//[TODO] these might be redundant
//			if ((Type.enumConstructor(reference) != 'EReference') &&
//			    (Type.enumConstructor(reference) != 'EArrayAccess'))
//				throw tokenizer.createSyntaxError('Invalid assignment left-hand side.');
				
			// compound postfix operation
			operands.push(EPostfix(reference, type));
		    
		    case PDot(identifier):
			// get property and base
		        var base:Expression = operands.pop();
			// compound reference
			operands.push(EReference(identifier, base));
		    
		    case PArrayAccess(index):
			// array access
			var reference:Expression = operands.pop();
			operands.push(EArrayAccess(reference, index));
		    
		    case PCall(args):
			// method call
			var method:Expression = operands.pop();
			operands.push(ECall(method, args));
		}
	}

// http://www.particle.kth.se/~lindsey/JavaCourse/Book/Part1/Java/Chapter02/operators.html

	private function lookupOperatorPrecedence(operator:ParserOperator)
	{
		return switch (operator)
		{
		    case PAssignment(_): 1;
		    case PConditional(_, _): 2;
		    case POperator(operator):
			switch (operator)
			{
			    case OpOr: 3;
			    case OpAnd: 4;
			    case OpBitwiseOr: 5;
			    case OpBitwiseXor: 6;
			    case OpBitwiseAnd: 7;
			    case OpEqual, OpUnequal: 8;
			    case OpLessThan, OpLessThanOrEqual, OpGreaterThan, OpGreaterThanOrEqual, OpInstanceOf: 9;
			    case OpLeftShift, OpRightShift, OpZeroRightShift: 10;
			    case OpPlus, OpMinus: 11;
			    case OpMultiply, OpDivide, OpModulus: 12;
			    case OpNot, OpBitwiseNot, OpUnaryPlus, OpUnaryMinus: 14;
			}
		    case PCast(_): 13;
		    case PPrefix(_): 14;
		    case PPostfix(_): 15;
		    case PDot(_): 15;
		    case PArrayAccess(_): 15;
		    case PCall(_): 15;
		}
	}
}

enum ParserOperator
{
	PConditional(thenExpression:Expression, elseExpression:Expression);
	PAssignment(?operator:Operator);
	POperator(operator:Operator);
	PCast(type:VariableType);
	PPrefix(type:IncrementType);
	
	// highest precedence (could be eliminated)
	PPostfix(type:IncrementType);
	PDot(identifier:String);
	PArrayAccess(index:Expression);
	PCall(args:Array<Expression>);
}
  
/*-------------------- bit array ----------------------------------*/

class BitSet 
{
	private var bitset:Array < Bool >;

	public function new(nbits:Int) 
	{
		bitset = [];
		for (i in 0...nbits)
			bitset.push(false);
	}
	
	inline public function get(bitIndex:Int):Bool
	{
		return bitset[bitIndex];
	}
	
	inline public function set(bitIndex:Int)
	{
		bitset[bitIndex] = true;
	}
	
	public function or(bitset2:BitSet)
	{
		for (i in 0...bitset.length)
			bitset[i] = bitset[i] || bitset2.get(i);
	}
}

$$$
