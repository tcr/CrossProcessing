/*-------------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported from C# to Java by Wolfgang Ahorner
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
------------------------------------------------------------------------*/
-->begin

class Parser {
-->constants
	inline static var T:Bool = true;
	inline static var x:Bool = false;
	static var minErrDist:Int = 2;

	public var t:Token;    // last recognized token
	public var la:Token;   // lookahead token
	var errDist:Int;
	
	public var scanner:Scanner;
	public var errors:Errors;

	-->declarations

	public function new(scanner:Scanner) {
		errDist = minErrDist;
		this.scanner = scanner;
		errors = new Errors();
	}

	function SynErr (n:Int):Void {
		if (errDist >= minErrDist) errors.SynErr(la.line, la.col, n);
		errDist = 0;
	}

	public function SemErr (msg:String):Void {
		if (errDist >= minErrDist) errors.SemErr(t.line, t.col, msg);
		errDist = 0;
	}
	
	function Get ():Void {
		while (true) {
			t = la;
			la = scanner.Scan();
			if (la.kind <= maxT) {
				++errDist;
				break;
			}
-->pragmas
			la = t;
		}
	}
	
	function Expect (n:Int):Void {
		if (la.kind==n) Get(); else { SynErr(n); }
	}
	
	function StartOf (s:Int):Bool {
		return set[s][la.kind];
	}
	
	function ExpectWeak (n:Int, follow:Int):Void {
		if (la.kind == n) Get();
		else {
			SynErr(n);
			while (!StartOf(follow)) Get();
		}
	}
	
	function WeakSeparator (n:Int, syFol:Int, repFol:Int):Bool {
		var kind:Int = la.kind;
		if (kind == n) { Get(); return true; }
		else if (StartOf(repFol)) return false;
		else {
			SynErr(n);
			while (!(set[syFol][kind] || set[repFol][kind] || set[0][kind])) {
				Get();
				kind = la.kind;
			}
			return StartOf(syFol);
		}
	}
	
-->productions

	public function Parse():PdeProgram {
		la = new Token();
		la.val = "";		
		Get();
		
		var ret:PdeProgram = -->parseRoot
		Expect(0);
		return ret;
	}

	private static var set:Array<Array<Bool>> = [
-->initialization
	];
} // end Parser


class Errors {
	public var count:Int;                                    // number of errors detected
//	public java.io.PrintStream errorStream = System.out;     // error messages go to this stream
	static var errMsgFormat:String = "-- line {0} col {1}: {2}"; // 0=line, 1=column, 2=text
	
	public function new() {
		count = 0;
	}
	
	public function printMsg(line:Int, column:Int, msg:String):Void {
		var b:String = errMsgFormat;
		b = StringTools.replace(b, '{0}', Std.string(line));
		b = StringTools.replace(b, '{1}', Std.string(column));
		b = StringTools.replace(b, '{2}', msg);
		trace(b);
	}
	
	public function SynErr (line:Int, col:Int, n:Int):Void {
		var s:String;
		switch (n) {-->errors
			default: s = "error " + n;
		}
		printMsg(line, col, s);
		count++;
		throw new FatalError(s);
	}

	public function SemErr (?line:Int, ?col:Int, s:String):Void {
		line == null ? printMsg(line, col, s) : trace(s);
		count++;
		throw new FatalError(s);
	}
	
	public function Warning (?line:Int, ?col:Int, s:String):Void {	
		line == null ? printMsg(line, col, s): trace(s);
	}
} // Errors

class FatalError {
	public var message:String;
	public static var serialVersionUID:Float = 1.0;
	public function new(s:String) { this.message = s; }
}

/*------------------------- modifier handling -----------------------------*/

class ModifierSet
{
	static public var none		= new EnumSet<Modifier>([]);
	static public var access	= new EnumSet<Modifier>([MPublic, MProtected, MPrivate]);
	static public var classes	= new EnumSet<Modifier>([MPublic, MProtected, MPrivate, MAbstract, MStatic, MFinal, MStrictfp]);
	static public var fields	= new EnumSet<Modifier>([MPublic, MProtected, MPrivate, MStatic, MFinal, MTransient, MVolatile]);
	static public var methods	= new EnumSet<Modifier>([MPublic, MProtected, MPrivate, MAbstract, MSynchronized, MNative, MStatic, MFinal, MStrictfp]);
	static public var constructors	= new EnumSet<Modifier>([MPublic, MProtected, MPrivate]);
	static public var interfaces	= new EnumSet<Modifier>([MPublic, MProtected, MPrivate, MAbstract, MStatic, MStrictfp]);
	static public var constants	= new EnumSet<Modifier>([MPublic, MStatic, MFinal]);
	static public var all		= new EnumSet<Modifier>([MPublic, MProtected, MPrivate, MAbstract, MVolatile, MTransient, MSynchronized, MNative, MStatic, MFinal, MStrictfp]);
}

/*-------------------- expression building ----------------------------------*/

class OperationBuilder
{
	private var operators:Array<InfixOperator>;
	private var operands:Array<Expression>;
	
	public function new() {
		operators = [];
		operands = [];
	}
	
	public function operator(operator:InfixOperator)
	{
		reduce(lookupOperatorPrecedence(operator));
		operators.push(operator);
	}
	
	public function operand(operand:Expression)
	{
		operands.push(operand);
	}
	
	public function reduce(?precedence:Int = 0):Expression
	{
		while (operators.length > 0 && lookupOperatorPrecedence(operators[operators.length - 1]) >= precedence)
			reduceOperator(operators.pop());
		return operands[0];
	}

	private function reduceOperator(operator:InfixOperator):Void
	{
		var b:Expression = operands.pop(), a:Expression = operands.pop();
		operands.push(EInfixOperation(operator, a, b));
	}
	
// http://www.particle.kth.se/~lindsey/JavaCourse/Book/Part1/Java/Chapter02/operators.html

	private function lookupOperatorPrecedence(operator:InfixOperator):Int
	{
		return switch (operator)
		{
		    case OpOr: 3;
		    case OpAnd: 4;
		    case OpBitwiseOr: 5;
		    case OpBitwiseXor: 6;
		    case OpBitwiseAnd: 7;
		    case OpEqual, OpUnequal: 8;
		    case OpLessThan, OpLessThanOrEqual, OpGreaterThan, OpGreaterThanOrEqual: 9;
		    case OpLeftShift, OpRightShift, OpZeroRightShift: 10;
		    case OpAdd, OpSubtract: 11;
		    case OpMultiply, OpDivide, OpModulus: 12;
		}
	}
}

/*-------------------- block scope ----------------------------------*/

interface LexicalResolver
{
	public function resolveLexicalGetter(identifier:String):Expression;
	public function resolveLexicalSetter(identifier:String, value:Expression):Expression;
}

class CompilationUnitContext
{
	public var definitions(default, null):Array<TopLevelDefinition>;
	
	private var resolveHash:Hash<Qualident>;
	public function resolveLexicalGetter(identifier:String):Expression
	{
		return resolveHash.has(identifier) ? EQualifiedReference(resolveHash.get(identifier)) : ELexReference(identifier);
	}
	public function resolveLexicalSetter(identifier:String, value:Expression):Expression
	{
//		return resolveHash.has(identifier) ? EQualifiedReference(resolveHash.get(identifier)) : ELexReference(identifier);
	}
	
	public function addImportDeclaration(ident:Qualident)
	{
		// check ident type
		if (ident.length == 0)
			throw "Invalid identifier";
		if (ident[ident.length - 1] != '*')
			resolveHash.set(ident[ident.length - 1], ident);
		else {
			// iterate namespace
			
		}
	}
	
	public function new()
	{
		definitions = [];
		resolveHash = new Hash<Qualident>();
	}
}

class ClassContext
{
	public var staticConstructor(default, null):BlockContext;
	public var objectConstructor(default, null):BlockContext;
	public var definitions(default, null):Array<ClassDefinition>;
	
	//[TODO] this should take no parent, prevent redefinition of variables/methods with redundant types(!)
	public function new()
	{
		definitions = [];
		staticConstructor = new BlockContext();
		objectConstructor = new BlockContext();
	}
	
	//[TODO] have to resolve inner class variables to accessors... yey
	public function resolveLexicalGetter(identifier:String):Expression;
	public function resolveLexicalSetter(identifier:String, value:Expression):Expression;
}

class BlockContext
{
	public var statements(default, null):Array<Statement>;
	public var definitions(default, null):Array<BlockDefinition>;
	
	//[TODO] this should take a parent, and prevent redefinition of variables?
	public function new()
	{
		statements = [];
		definitions = [];
	}
	
	public function getBlockStatement():Statement {
		return SBlock(definitions, statements);
	}
	
	//[TODO] not much here, just forward them to owner
	public function resolveLexicalGetter(identifier:String):Expression;
	public function resolveLexicalSetter(identifier:String, value:Expression):Expression;
}

/*-------------------- PdeProgram ----------------------------------*/

interface CompilationUnit
{
	var packageQualident:Qualident;
	var definitions:Array<TopLevelDefinition>;
}

//[TODO] writeImports: http://dev.processing.org/source/index.cgi/trunk/processing/app/src/processing/app/preproc/PdePreprocessor.java?view=markup

class JavaProgram extends CompilationUnitScope, implements CompilationUnit
{
	public var packageQualident(default, null):Qualident;
	
	public function new()
	{
		super();
		
		packageQualident = [];
	}
}

class ActiveProgram extends JavaProgram
{
	public var classScope(default, null):ClassContext;
	
	public function new(programName:String)
	{
		super();
		
		// create class
		classScope = new ClassContext();
		definitions.push(DClass(programName, new EnumSet<Modifier>([MPublic]), classScope.definitions, DTReference(['PApplet'])));
	}
}

class StaticProgram extends ActiveProgram
{
	public var methodScope(default, null):BlockContext;
	
	public function new(programName:String)
	{
		super(programName);
		
		// create setup method
		methodScope = new BlockContext();
		classScope.definitions.push(DMethod('setup', null, new EnumSet<Modifier>(), [], methodScope.blockStatement));
	}
}

/*-------------------- PdeProgram ----------------------------------*/
/*
interface CompilationUnit
{
	public function getPackage():Array<String>;
	public function getDefinitions():Array<TopLevelDefinition>;
}

//[TODO] writeImports: http://dev.processing.org/source/index.cgi/trunk/processing/app/src/processing/app/preproc/PdePreprocessor.java?view=markup

class JavaProgram implements CompilationUnit
{
	private var packageQualident:Array<String>;
	public function setPackage(qualident:Array<String>) { packageQualident = qualident; }
	public function getPackage():Array < String > { return packageQualident; }
	
	public function getCompilationUnitScope
}

class ActiveProgram extends JavaProgram
{
	private var packageQualident:Array<String>;
	public function setPackage(qualident:Array<String>) { packageQualident = qualident; }
	public function getPackage():Array <String> { return packageQualident; }
	
	public function getCompilationUnit(identifier:String):CompilationUnit
	{
		// create class extension
		var classDefinition = DClass(identifier, new EnumSet<Modifier>([MPublic]), definitions, DTReference(['PApplet']));

		// create compilation unit
		return {
		    packageIdent: [],
		    importIdents: [['xpde', 'core', '*'], ['xpde', 'xml', '*']],
		    definitions: [classDefinition]
		};
	}
}

class StaticProgram extends BlockScope, implements CompilationUnit
{
	public function getCompilationUnit(identifier:String):CompilationUnit
	{
		// create setup function
		var setupDefinition = DMethod('setup', null, new EnumSet<Modifier>(), [], getStatement());
	
		// create class extension
		var classDefinition = DClass(identifier, new EnumSet<Modifier>([MPublic]), [setupDefinition], DTReference(['PApplet']));

		// create compilation unit
		return {
		    packageIdent: [],
		    importIdents: [],
		    definitions: [classDefinition]
		};
	}
}*/
  
/*-------------------- bit array ----------------------------------*/

class BitSet 
{
	private var bitset:Array < Bool >;

	public function new(nbits:Int) 
	{
		bitset = [];
		for (i in 0...nbits)
			bitset.push(false);
	}
	
	inline public function get(bitIndex:Int):Bool
	{
		return bitset[bitIndex];
	}
	
	inline public function set(bitIndex:Int)
	{
		bitset[bitIndex] = true;
	}
	
	public function or(bitset2:BitSet)
	{
		for (i in 0...bitset.length)
			bitset[i] = bitset[i] || bitset2.get(i);
	}
}

$$$
