/*-------------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported from C# to Java by Wolfgang Ahorner
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
------------------------------------------------------------------------*/
-->begin

class Parser
{
-->constants
	static var minErrDist:Int = 2;

	public var t:Token;    // last recognized token
	public var la:Token;   // lookahead token
	var errDist:Int;
	
	public var scanner:Scanner;
	public var errors:Errors;

	-->declarations
	
	public var unit:ParsedCompilationUnit;

	public function new(scanner:Scanner, unit:ParsedCompilationUnit) {
		errDist = minErrDist;
		this.scanner = scanner;
		this.unit = unit;
		errors = new Errors();
		
		// parsing contexts
		classContexts = [];
		blockContexts = [];
	}

	function SynErr (n:Int):Void {
		if (errDist >= minErrDist) errors.SynErr(la.line, la.col, n);
		errDist = 0;
	}

	public function SemErr (msg:String):Void {
		if (errDist >= minErrDist) errors.SemErr(t.line, t.col, msg);
		errDist = 0;
	}
	
	function Get ():Void {
		while (true) {
			t = la;
			la = scanner.Scan();
			if (la.kind <= maxT) {
				++errDist;
				break;
			}
-->pragmas
			la = t;
		}
	}
	
	function Expect (n:Int):Void {
		if (la.kind==n) Get(); else { SynErr(n); }
	}
	
	function StartOf (s:Int):Bool {
		return set[s][la.kind];
	}
	
	function ExpectWeak (n:Int, follow:Int):Void {
		if (la.kind == n) Get();
		else {
			SynErr(n);
			while (!StartOf(follow)) Get();
		}
	}
	
	function WeakSeparator (n:Int, syFol:Int, repFol:Int):Bool {
		var kind:Int = la.kind;
		if (kind == n) { Get(); return true; }
		else if (StartOf(repFol)) return false;
		else {
			SynErr(n);
			while (!(set[syFol][kind] || set[repFol][kind] || set[0][kind])) {
				Get();
				kind = la.kind;
			}
			return StartOf(syFol);
		}
	}
	
-->productions

	public function Parse():Void {
		// parse AST
		la = new Token();
		la.val = "";		
		Get();
-->parseRoot
		Expect(0);
		
		// second pass
		(new LexicalResolver()).resolve(unit);
	}

	inline static var T:Bool = true;
	inline static var x:Bool = false;
	private static var set:Array<Array<Bool>> = [
-->initialization
	];
}

class Errors
{
	public var count:Int;                                    // number of errors detected
	static var errMsgFormat:String = "-- line {0} col {1}: {2}"; // 0=line, 1=column, 2=text
	
	public function new() {
		count = 0;
	}
	
	public function printMsg(line:Int, column:Int, msg:String):Void {
		var b:String = errMsgFormat;
		b = StringTools.replace(b, '{0}', Std.string(line));
		b = StringTools.replace(b, '{1}', Std.string(column));
		b = StringTools.replace(b, '{2}', msg);
		trace(b);
	}
	
	public function SynErr (line:Int, col:Int, n:Int):Void {
		var s:String;
		switch (n) {-->errors
			default: s = "error " + n;
		}
		printMsg(line, col, s);
		count++;
		throw new FatalError(s);
	}

	public function SemErr (?line:Int, ?col:Int, s:String):Void {
		line == null ? printMsg(line, col, s) : trace(s);
		count++;
		throw new FatalError(s);
	}
	
	public function Warning (?line:Int, ?col:Int, s:String):Void {	
		line == null ? printMsg(line, col, s): trace(s);
	}
}

class FatalError
{
	public var message:String;
	public static var serialVersionUID:Float = 1.0;
	public function new(s:String) { this.message = s; }
}

/*------------------------- modifier handling -----------------------------*/

class ModifierSet
{
	static public var none		= new EnumSet<Modifier>([]);
	static public var access	= new EnumSet<Modifier>([MPublic, MProtected, MPrivate]);
	static public var classes	= new EnumSet<Modifier>([MPublic, MProtected, MPrivate, MAbstract, MStatic, MFinal, MStrictfp]);
	static public var fields	= new EnumSet<Modifier>([MPublic, MProtected, MPrivate, MStatic, MFinal, MTransient, MVolatile]);
	static public var methods	= new EnumSet<Modifier>([MPublic, MProtected, MPrivate, MAbstract, MSynchronized, MNative, MStatic, MFinal, MStrictfp]);
	static public var constructors	= new EnumSet<Modifier>([MPublic, MProtected, MPrivate]);
	static public var interfaces	= new EnumSet<Modifier>([MPublic, MProtected, MPrivate, MAbstract, MStatic, MStrictfp]);
	static public var constants	= new EnumSet<Modifier>([MPublic, MStatic, MFinal]);
	static public var all		= new EnumSet<Modifier>([MPublic, MProtected, MPrivate, MAbstract, MVolatile, MTransient, MSynchronized, MNative, MStatic, MFinal, MStrictfp]);
}

/*-------------------- expression building ----------------------------------*/

class OperationBuilder
{
	private var operators:Array<InfixOperator>;
	private var operands:Array<Expression>;
	
	public function new() {
		operators = [];
		operands = [];
	}
	
	public function operator(operator:InfixOperator)
	{
		reduce(lookupOperatorPrecedence(operator));
		operators.push(operator);
	}
	
	public function operand(operand:Expression)
	{
		operands.push(operand);
	}
	
	public function reduce(?precedence:Int = 0):Expression
	{
		while (operators.length > 0 && lookupOperatorPrecedence(operators[operators.length - 1]) >= precedence)
			reduceOperator(operators.pop());
		return operands[0];
	}

	private function reduceOperator(operator:InfixOperator):Void
	{
		var b:Expression = operands.pop(), a:Expression = operands.pop();
		operands.push(EInfixOperation(operator, a, b));
	}
	
// http://www.particle.kth.se/~lindsey/JavaCourse/Book/Part1/Java/Chapter02/operators.html

	private function lookupOperatorPrecedence(operator:InfixOperator):Int
	{
		return switch (operator)
		{
		    case OpOr: 3;
		    case OpAnd: 4;
		    case OpBitwiseOr: 5;
		    case OpBitwiseXor: 6;
		    case OpBitwiseAnd: 7;
		    case OpEqual, OpUnequal: 8;
		    case OpLessThan, OpLessThanOrEqual, OpGreaterThan, OpGreaterThanOrEqual: 9;
		    case OpLeftShift, OpRightShift, OpZeroRightShift: 10;
		    case OpAdd, OpSubtract: 11;
		    case OpMultiply, OpDivide, OpModulus: 12;
		}
	}
}

/*-------------------- Packages ----------------------------------*/

class JavaPackage implements JavaPackageItem
{
	public var contents(default, null):Hash<JavaPackageItem>;
	
	public function new()
	{
		contents = new Hash<JavaPackageItem>();
	}
	
	public function addCompilationUnit(qualident:Qualident, unit:CompilationUnit)
	{
		if (qualident.length == 1)
			if (contents.exists(qualident[0]))
				throw "redefinition of " + qualident.join('.');
			else
				contents.set(qualident[0], unit);
		else {
			if (contents.exists(qualident[0]) && !Std.is(contents.get(qualident[0]), JavaPackage))
				throw qualident.join('.') + " is not a package";
			else if (!contents.exists(qualident[0]))
				contents.set(qualident[0], new JavaPackage());
			(cast(contents.get(qualident[0]), JavaPackage)).addCompilationUnit(qualident.slice(1), unit);
		}
	}
	
	public function getByQualident(qualident:Qualident):JavaPackageItem
	{
		try {
			if (!contents.exists(qualident[0]))
				throw false;
			if (qualident.length == 1)
				return contents.get(qualident[0]);
			else
				return cast(contents.get(qualident[0]), JavaPackage).getByQualident(qualident.slice(1));
			
		} catch (e:Dynamic)
		{
			throw "invalid qualified reference " + qualident.join('.');
		}
	}
}

interface JavaPackageItem { }

interface CompilationUnit implements JavaPackageItem
{
	var packageDeclaration(default, null):Qualident;
	var dependencies(default, null):Array<Qualident>;
	function generateDefinitions():Void;
//	function compile(compiler:ICompiler):Void;
}

class ParsedCompilationUnit implements CompilationUnit
{	
	public var packageDeclaration(default, null):Qualident;
	public var dependencies(default, null):Array<Qualident>;
	
	public var context(default, null):CompilationUnitContext;	
	private var source:Input;
	
	public function new(rootPackage:JavaPackage, packageDeclaration:Qualident, source:Input)
	{
		// add compilation unit to package
		this.packageDeclaration = packageDeclaration;
		rootPackage.addCompilationUnit(packageDeclaration, this);
		this.source = source;
	}
	
	private var context:CompilationUnitContext;
	
	private function parseSource()
	{
		if (context != null)
		{
			// create parsing context
			context = new CompilationUnitContext(rootPackage, this);
			
			// scan and compile
			var scanner:Scanner = new Scanner(source);
			var parser:Parser = new Parser(scanner, context);
			parser.Parse();
			
			// validate package declaration
		}
	}
	
	private var definitions:Array<TopLevelDefinition>;
	
	public function generateDefinitions()
	{
		if (definitions == null)
		{
			//[TODO] how do dependencies fit in
			dependencies = [];
		}
	}
}

/*-------------------- block scope ----------------------------------*/

class CompilationUnitContext
{
	private var unit:CompilationUnit;
	private var rootPackage:JavaPackage;
	
	public function new(rootPackage:JavaPackage, unit:CompilationUnit)
	{
		this.unit = unit;
		this.rootPackage = rootPackage;
		
		definitions = new Hash<TopLevelDefinition>();
		importMap = new Hash<Qualident>();
	}
	
	public var definitions:Hash<TopLevelDefinition>;
	
	private function define(identifier:String, definition:TopLevelDefinition)
	{
		if (definitions.exists(identifier))
			throw 'redefinition of top-level declaration "' + identifier + '"';
		definitions.set(identifier, definition);
	}
	
	public function defineClass(definition:ClassDefinition)
	{
		define(definition.identifier, DClass(definition));
	}
	
/*	public function defineInterface(interface:InterfaceDefinition)
	{
		define(definition.identifier, DInterface(definition));
	}*/
	
	/* imports */
	
	private var importMap:Hash<Qualident>;
	
	public function mapImports(ident:Qualident)
	{
		// check ident type
		if (ident[ident.length - 1] != '*')
		{
			// check that the compilation unit exists
			if (!Std.is(rootPackage.getByQualident(ident.slice(0, -1)), CompilationUnit))
				return;
			importMap.set(ident[ident.length - 1], ident);
		}
		else
		{
			// iterate namespace
			try {
				var importPackage = cast(rootPackage.getByQualident(ident.slice(0, -1)), JavaPackage);
				for (item in importPackage.contents.keys())
					if (Std.is(importPackage.contents.get(item), CompilationUnit))
						importMap.set(item, ident.slice(0, -1).concat([item]));
			}
			catch (e:Dynamic) { }
		}
	}
}

interface FieldDefinable
{
	function defineField(definition:FieldDefinition, ?init:Expression):Void;
}

class ClassContext implements FieldDefinable
{
	// typedef: ClassDefinition
	public var identifier:String;
	public var modifiers:EnumSet<Modifier>;
	public var extend:DataType;
	public var implement:Array<DataType>;
	public var fields:Hash<FieldDefinition>;
	public var methods:Hash<MethodDefinition>;

	// constructors
	public var staticConstructor:BlockContext;
	public var objectConstructor:BlockContext;

	public function new(modifiers:EnumSet<Modifier>, identifier:String)
	{
		// definition defaults
		this.modifiers = modifiers;
		this.identifier = identifier;	
		implement = [];
		fields = new Hash<FieldDefinition>();
		methods = new Hash<MethodDefinition>();
		
		// constructors
		staticConstructor = new BlockContext();
		objectConstructor = new BlockContext();
	}
	
	public function defineField(definition:FieldDefinition, ?init:Expression)
	{
		if (fields.exists(definition.identifier))
			throw 'redeclaration of field "' + definition.identifier + '"';
		fields.set(definition.identifier, definition);
		if (init != null)
			definition.modifiers.contains(MStatic) ?
			    staticConstructor.pushStatement(SExpression(EAssignment(definition.identifier, ELexExpression(LReference(this.identifier)), init))) :
			    objectConstructor.pushStatement(SExpression(EAssignment(definition.identifier, EThisReference, init)));
	}
	
	public function defineMethod(definition:MethodDefinition)
	{
//[TODO] hash by method signature!
//		if (methodDefinitions.exists(definition.identifier))
//			throw 'redefinition of top-level declaration "' + identifier + '"';
		methods.set(definition.identifier, definition);
	}
}

class BlockContext implements FieldDefinable
{
	public var statements(default, null):Array<Statement>;
	
	public function pushStatement(statement:Statement)
	{
		statements.push(statement);
	}
	
	private var fieldDefinitions(default, null):Hash<FieldDefinition>;
	
	public function defineField(definition:FieldDefinition, ?init:Expression)
	{
		if (isFieldDefined(definition.identifier))
			throw 'redeclaration of variable "' + definition.identifier + '" in block scope';
		fieldDefinitions.set(definition.identifier, definition);
		if (init != null)
			pushStatement(SExpression(ELocalAssignment(definition.identifier, init)));
	}
	
	public function isFieldDefined(identifier:String):Bool
	{
		return fieldDefinitions.exists(identifier) || (parent != null ? parent.isFieldDefined(identifier) : false);
	}
	
	private var parent:BlockContext;
	
	public function new(?parent:BlockContext)
	{
		this.parent = parent;
		
		statements = [];
		fieldDefinitions = new Hash<FieldDefinition>();
	}
	
	public function getBlockStatement():Statement
	{
		return SBlock(fieldDefinitions, statements);
	}
}

class MethodContext
{
	// typedef: MethodDefinition
	public var identifier:String;
	public var type:Null<DataType>;
	public var modifiers:EnumSet<Modifier>;
	public var throwsList:Array<Qualident>;
	public var parameters:Array<FormalParameter>;
	
	// method body
	public var body:Statement;
	
	public function new(modifiers:EnumSet<Modifier>, type:Null<DataType>, identifier:String)
	{
		// definition defaults
		this.modifiers = modifiers;
		this.type = type;
		this.identifier = identifier;
		throwsList = [];
		parameters = [];
	}
}

/*-------------------- lexical resolution (second pass) ----------------------------------*/

class LexicalResolver
{
	private var unit:ParsedCompilationUnit;
	private var classContext:ClassContext;
	
	public function new()
	{
	}
	
	public function resolve(unit:ParsedCompilationUnit)
	{
		this.unit = unit;
		for (definition in unit.context.definitions)
			switch (definition) {
			    case DClass(definition):
				resolveClass(cast(definition, ClassContext));
			}
	}
	
	function resolveClass(definition:ClassContext)
	{
		classContext = definition;
		for (method in classContext.methods)
			resolveMethod(cast(method, MethodContext));
		resolveStatement(classContext.staticConstructor.getBlockStatement());
		resolveStatement(classContext.objectConstructor.getBlockStatement());
	}
	
	function resolveMethod(definition:MethodContext)
	{
		if (definition.body != null)
			resolveStatement(definition.body);
	}
	
	function resolveStatement(statement:Statement)
	{
		switch (statement)
		{
		    case SBlock(_, statements):
			for (statement in statements)
				resolveStatement(statement);
				
		    case SBreak(_):
		    
		    case SConditional(_, thenBlock, elseBlock):
			resolveExpression(Type.enumParameters(statement), 0);
			resolveStatement(thenBlock);
			if (elseBlock != null)
				resolveStatement(elseBlock);
				
		    case SContinue(_):
		    
		    case SExpression(_):
			resolveExpression(Type.enumParameters(statement), 0);
		    
		    case SLabel(_, body):
			resolveStatement(body);
			
		    case SLoop(_, body, _):
			resolveExpression(Type.enumParameters(statement), 0);
			resolveStatement(body);
			
		    case SReturn(value):
			if (value != null)
				resolveExpression(Type.enumParameters(statement), 0);
				
		    case SThrow(_):
			resolveExpression(Type.enumParameters(statement), 0);
			
		    case STry(body, catches, finallyBody):
			resolveStatement(body);
			for (catchBlock in catches)
				resolveStatement(catchBlock.body);
			if (finallyBody != null)
				resolveStatement(finallyBody);
		}
	}
	
	function resolveExpression(array:Array<Dynamic>, index:Int)
	{
		var expression:Expression = untyped array[index];
		switch (expression)
		{
		    // instantiation
		    case EArrayInstantiation(_, sizes):
			for (index in 0...sizes.length)
				resolveExpression(sizes, index);
				
		    case EObjectInstantiation(_, args):
			for (index in 0...args.length)
				resolveExpression(args, index);
		
		    // control
		    case EConditional(_, _, _):
			resolveExpression(Type.enumParameters(expression), 0);
			resolveExpression(Type.enumParameters(expression), 1);
			resolveExpression(Type.enumParameters(expression), 2);
			
		    // references
		    case EArrayAccess(_, _):
			resolveExpression(Type.enumParameters(expression), 0);
			resolveExpression(Type.enumParameters(expression), 1);
			
		    case ELocalReference(_):
		    case EReference(_, _):
			resolveExpression(Type.enumParameters(expression), 1);
			
		    case EQualifiedReference(_):
		    case ESuperReference:
		    case EThisReference:
		    // calling
		    case ECall(_, _, args):
			resolveExpression(Type.enumParameters(expression), 1);
			for (index in 0...args.length)
				resolveExpression(args, index);
				
		    case EThisCall(args):
			for (index in 0...args.length)
				resolveExpression(args, index);
		    case ESuperCall(args):
			for (index in 0...args.length)
				resolveExpression(args, index);
		    // assignment
		    case EArrayAssignment(_, _, _):
			resolveExpression(Type.enumParameters(expression), 0);
			resolveExpression(Type.enumParameters(expression), 1);
			resolveExpression(Type.enumParameters(expression), 2);
			
		    case EAssignment(_, _, _):
			resolveExpression(Type.enumParameters(expression), 1);
			resolveExpression(Type.enumParameters(expression), 2);
			
		    case ELocalAssignment(_, _):
			resolveExpression(Type.enumParameters(expression), 1);
		    // operations
		    case ECast(_, _):
			resolveExpression(Type.enumParameters(expression), 1);
		    case EPrefixOperation(_, _):
			resolveExpression(Type.enumParameters(expression), 1);
		    case EInfixOperation(_, _, _):
			resolveExpression(Type.enumParameters(expression), 1);
			resolveExpression(Type.enumParameters(expression), 2);
		    case EInstanceOf(_, _):
			resolveExpression(Type.enumParameters(expression), 0);
		    case EPrefix(_, _):
			resolveExpression(Type.enumParameters(expression), 1);
		    case EPostfix(_, _):
			resolveExpression(Type.enumParameters(expression), 1);
		
		    // literals
		    case EArrayLiteral(values):
			for (index in 0...values.length)
				resolveExpression(values, index);
				
		    case EStringLiteral(_):
		    case EIntegerLiteral(_):
		    case EFloatLiteral(_):
		    case ECharLiteral(_):
		    case EBooleanLiteral(_):
		    case ENull:
		
		    // second pass
		    case ELexExpression(expression):
			switch (expression) {
			    case LReference(identifier): array[index] = resolveLexicalReference(identifier);
			    case LCall(identifier, args): array[index] = resolveLexicalCall(identifier, args);
			    case LAssignment(identifier, value): array[index] = resolveLexicalAssignment(identifier, value);
			}
		}
	}
	
	/* lexical resolution */
	
//TODO:
// resolve class fields to this.variable accessors
// resolve inner class variables to accessors
// resolve types to qualified references, add dependencies
	
/*	public function resolveLexicalType(identifier:String):DataType
	{
		
	}*/
	
	public function resolveLexicalReference(identifier:String):Expression
	{
		// class fields
		if (classContext.fields.exists(identifier))
			return EReference(identifier, EThisReference);
			
		// no variable found
		throw 'invalid reference to variable "' + identifier + '"';
	}
	
	public function resolveLexicalAssignment(identifier:String, value:Expression):Expression
	{
		// class fields
		if (classContext.fields.exists(identifier))
			return EAssignment(identifier, EThisReference, value);
			
		// no variable found
		throw 'invalid reference to variable "' + identifier + '"';
	}
	
	public function resolveLexicalCall(identifier:String, args:Array<Expression>):Expression
	{
		// class methods
		if (classContext.methods.exists(identifier))
			return ECall(identifier, EThisReference, args);
			
		// no method found
		throw 'invalid call to method "' + identifier + '"';
	}
	
/* unit-level lexical resolution 
	
	public function resolveLexicalType(identifier:String):DataType
	{
		// only qualified references should get this far
		if (!importMap.exists(identifier))
			throw "reference to undeclared type " + identifier;
		// add to dependencies map
		unit.dependencies.push(importMap.get(identifier));
		// return datatype
		return DTReference(importMap.get(identifier));
	}
	
	public function resolveLexicalGetter(identifier:String):Expression
	{
		// check for a qualified reference
		if (!importMap.exists(identifier))
			return ELexReference(identifier);
		// add to dependencies map
		unit.dependencies.push(importMap.get(identifier));
		// return expression
		return EQualifiedReference(importMap.get(identifier));
	}
	
	public function resolveLexicalSetter(identifier:String, value:Expression):Expression
	{
		// lexical setter
		return ELexAssignment(identifier, value);
	}*/
}
  
/*-------------------- bit array ----------------------------------*/

class BitSet 
{
	private var bitset:Array < Bool >;

	public function new(nbits:Int) 
	{
		bitset = [];
		for (i in 0...nbits)
			bitset.push(false);
	}
	
	inline public function get(bitIndex:Int):Bool
	{
		return bitset[bitIndex];
	}
	
	inline public function set(bitIndex:Int)
	{
		bitset[bitIndex] = true;
	}
	
	public function or(bitset2:BitSet)
	{
		for (i in 0...bitset.length)
			bitset[i] = bitset[i] || bitset2.get(i);
	}
}

/*------------------- enum set -----------------------------*/

class EnumSet<T>
{
	private var set:Array<T>;

	public function new(?enums:Array<Dynamic>)
	{
		set = [];
		if (enums != null)
			for (item in enums)
				add(item);
	}
	
	public function add(item:T)
	{
		if (!contains(item))
			set.push(item);
	}

	public function contains(itemA:T)
	{
		for (itemB in set)
			if (Type.enumEq(itemA, itemB))
				return true;
		return false;
	}
	
	public function iterator():Iterator<T>
	{
		return set.iterator();
	}
	
	public function toString():String
	{
		return set.join(' ');
	}
}

$$$
