import xpde.Rtti;
import xpde.parser.Scanner;
import xpde.parser.Context;
import xpde.parser.AST;
import haxe.io.Input;

COMPILER PdeProgram
  
/*---------------------------- token sets -----------------------------------*/

static var maxTerminals:Int = 160;  // set size

static function newSet(values:Array<Int>):BitSet {
  var s:BitSet = new BitSet(maxTerminals);
  for (i in 0...values.length) s.set(values[i]);
  return s;
}

static function or(s1:BitSet, s2:BitSet):BitSet {
  s1.or(s2);
  return s1;
}

static var typeKWarr:Array<Int> = [_byte, _short, _char, _int, _long, _float, _double, 
                          _boolean];
static var castFollowerArr:Array<Int> = [_ident, _new, _super, _this, _void, _intLit,
                                _floatLit, _charLit, _stringLit, _true, _false,
                                _null, _lpar, _not, _tilde];
static var prefixArr:Array<Int> = [_inc, _dec, _not, _tilde, _plus, _minus];                                

static var typeKW:BitSet       = newSet(typeKWarr);
static var castFollower:BitSet = or(newSet(castFollowerArr), typeKW);
static var prefix:BitSet       = newSet(prefixArr);

/*---------------------------- auxiliary methods ----------------------------*/

public function error (s:String):Void {
  if (errDist >= minErrDist) errors.SemErr(la.line, la.col, s);
  errDist = 0;
}

// "(" BasicType {"[""]"} ")"
function isSimpleTypeCast ():Bool {
  // assert: la.kind == _lpar
  scanner.ResetPeek();
  var pt1:Token = scanner.Peek();
  
  if (typeKW.get(pt1.kind)) {
    var pt:Token = scanner.Peek();
    pt = skipDims(pt);
    if (pt != null) {
      return pt.kind == _rpar;
    }
  }
  return false;
}

// "(" Qualident {"[" "]"} ")" castFollower
function guessTypeCast ():Bool {
  // assert: la.kind == _lpar
  scanner.ResetPeek();
  var pt:Token = scanner.Peek();
  pt = rdQualident(pt);
  if (pt != null) {
    pt = skipDims(pt);
    if (pt != null) {
      var pt1:Token = scanner.Peek();
      return pt.kind == _rpar && castFollower.get(pt1.kind);
    }
  }
  return false;
}

// "[" "]"
function skipDims (pt:Token):Token {
  if (pt.kind != _lbrack) return pt;
  do {
     pt = scanner.Peek();
    if (pt.kind != _rbrack) return null;
     pt = scanner.Peek();
  } while (pt.kind == _lbrack);  
  return pt;
}

/* Checks whether the next sequence of tokens is a qualident *
 * and returns the qualident string                          *
 * !!! Proceeds from current peek position !!!               */
function rdQualident (pt:Token):Token {
  var qualident:String = "";
  
  if (pt.kind == _ident) {
    qualident = pt.val;
    pt = scanner.Peek();
    while (pt.kind == _dot) {
      pt = scanner.Peek();
      if (pt.kind != _ident) return null;
      qualident += "." + pt.val;
      pt = scanner.Peek();
    }
    return pt;
  } else return null;
}

// Return the n-th token after the current lookahead token
function peek(n:Int):Token {
  scanner.ResetPeek();
  var x:Token = la;
  while (n > 0) { x = scanner.Peek(); n--; }
  return x;
}


function checkExprStat(expression:Expression):Void {
	switch (expression)
	{
	    // instantiation
	    case EObjectInstantiation(_, _):
	    
	    // calling
	    case ECall(_, _, _):
	    case EThisCall(_):
	    case ESuperCall(_):
	    // assignment
	    case EArrayAssignment(_, _, _):
	    case EAssignment(_, _, _):
	    case ELocalAssignment(_, _):
	    
	    // operations
	    case EPrefix(_, _):
	    case EPostfix(_, _):
	    
	    // second pass
	    case ELexExpression(expression):
		switch (expression) {
		    case LCall(_, _):
		    case LAssignment(_, _):
		    default: error("not a statement" + " (" + expression + ")");
		}
	    
	    default: error("not a statement" + " (" + expression + ")");
	}
}

/*---------------------------- type ----------------------------*/
/*
function compoundBrackets(type:ParserDataType, bCount:Int):ParserDataType {
	if (bCount == 0)
		return type;
	switch (type) {
	    case DTPrimitive(type): return DTPrimitiveArray(type, bCount);
	    case DTPrimitiveArray(type, dimensions): return DTPrimitiveArray(type, dimensions + bCount);
	    case DTReference(qualident): return DTReferenceArray(qualident, bCount);
	    case DTReferenceArray(qualident, dimensions): return DTReferenceArray(qualident, dimensions + bCount);
	}
}
*/
/*---------------------------- modifiers ----------------------------*/

function addModifier(set:EnumSet<Modifier>, modifier:Modifier):Void {
	if (set.contains(modifier))
		error("repeated modifier " + modifier);
	else
		set.add(modifier);
}

function checkModifierPermission(set:EnumSet<Modifier>, permission:EnumSet<Modifier>):Void {
	for (modifier in set)
		if (!permission.contains(modifier))
			error("modifier(s) " + set + "not allowed here");
	else
		checkModifierAccess(set);
}

function checkModifierAccess(set:EnumSet<Modifier>):Void {
	var access:Int = 0;
	if (set.contains(MPublic))
		access++;
	if (set.contains(MPrivate))
		access++;
	if (set.contains(MProtected))
		access++;
	if (access > 1)
		error("illegal combination of modifiers: " + set);
}

/*---------------------------- contexts ----------------------------*/

var classContexts:Array<ClassContext>;
//var blockContexts:Array<BlockContext>;

function getClassPrefix():String
{
	var prefix = '';
	for (context in classContexts)
		prefix = context.identifier + '$' + prefix;
	return prefix;
}

/*-----------------------------------------------------------------*
 * Resolver routines to resolve LL(1) conflicts:                   *
 * These routines return a boolean value that indicates            *
 * whether the alternative at hand shall be choosen or not.        *
 * They are used in IF ( ... ) expressions.                        *       
 *-----------------------------------------------------------------*/

// ',' (no '}')
function commaAndNoRBrace():Bool {
  return (la.kind == _comma && peek(1).kind != _rbrace);
}

// '.' ident
function dotAndIdent():Bool {
  return la.kind == _dot && peek(1).kind == _ident;
}

// ident '('
function identAndLPar ():Bool {
  return la.kind == _ident && peek(1).kind == _lpar;
}

// ident ':'
function isLabel():Bool {
  return la.kind == _ident && peek(1).kind == _colon;
}

// '[' (no ']')
function nonEmptyBracket():Bool {
  return (la.kind == _lbrack && peek(1).kind != _rbrack);
}

// '['']'
function emptyBracket():Bool {
  return (la.kind == _lbrack && peek(1).kind == _rbrack);
}

// final or Type ident
function isLocalVarDecl(finalIsSuccess:Bool):Bool {
  var pt:Token = la;
  scanner.ResetPeek();
  
  if (la.kind == _final) 
    if (finalIsSuccess) return true;
    else pt = scanner.Peek();

  // basicType | ident
  if (typeKW.get(pt.kind))
    pt = scanner.Peek();
  else
    pt = rdQualident(pt);
    
  if (pt != null) {
    pt = skipDims(pt);
    if (pt != null) {
      return pt.kind == _ident;
    }
  }
  return false;
}

function isTypeCast():Bool {
  if (la.kind != _lpar) return false;
  if (isSimpleTypeCast()) return true;
  return guessTypeCast();
}

// '.' ("super" '.' | "class" | "this") | '(' | '['']'
function isIdentSuffix():Bool {
  if (la.kind == _dot) {
    scanner.ResetPeek();
    var pt:Token = scanner.Peek();
    if (pt.kind == _super) return scanner.Peek().kind == _dot;
    return (pt.kind == _class || pt.kind == _this);
  }
  return (la.kind == _lpar || emptyBracket());
}

/*--------------------------- program type -------------------------*/

/* http://dev.processing.org/source/index.cgi/trunk/processing/app/src/processing/app/preproc/pde.g?view=markup */

function isJavaProgram():Bool {
	return (la.kind == _public && peek(1).kind == _class);
}

function isActiveProgram():Bool {
	return (la.kind == _void && peek(1).kind == _ident && peek(2).kind == _lpar);
}

/*[NOTE] pde vs. java changes are available here:
http://dev.processing.org/source/index.cgi/trunk/processing/app/src/processing/app/preproc/pde.g?view=markup */

/*-------------------------------------------------------------------------*/

CHARACTERS
  tab           = '\u0009'. /*  9 = tabulator */
  lf            = '\u000a'. /* 10 = line feed */
  cr            = '\u000d'. /* 13 = carriage return */

  zero          = '0'.
  zeroToThree   = zero + "123" .
  octalDigit    = zero + "1234567" . 
  nonZeroDigit  = "123456789".
  digit         = '0' + nonZeroDigit .
  hexDigit      = digit + "ABCDEFabcdef" .
  letter        = 'A' .. 'Z' + 'a' .. 'z' + '_' + '$'.

  char          = ANY - "'" - '\\' - cr - lf.
  stringChar    = ANY - "\"" - '\\' - cr - lf.

TOKENS
  ident         = letter { letter | digit }.
  /*-------------------------------------------------------------------------*/
  intLit = 
  (  zero | nonZeroDigit { digit }
  | ( "0x" | "0X" ) hexDigit { hexDigit }
  | '0' octalDigit { octalDigit }
  ) [ "l" | "L" ].
  /*-------------------------------------------------------------------------*/
  floatLit =
    "." digit {digit} 
    [("e" | "E") ["+" | "-"] digit {digit}] 
    [ "F" | "f" | "D" | "d" ]
  | digit {digit} 
    ( "." {digit} 
      [("e" | "E" ) ["+" | "-"] digit {digit} ] 
      [ "F" | "f" | "D" | "d" ]
    | ("e" | "E") ["+" | "-"] digit {digit}
      [ "F" | "f" | "D" | "d" ]
    | "F" | "f" | "D" | "d"
    ).  
  /*-------------------------------------------------------------------------*/
  charLit = 
    "'" ( char
        | "\\" ( "b" | "t" | "n" | "f" | "r" | "\"" | "\'" | "\\"
               | "u" { "u" } hexDigit hexDigit hexDigit hexDigit
               | zeroToThree [ octalDigit ] [ octalDigit ]
               | octalDigit [ octalDigit ]
               )
        ) 
    "'".
  /*-------------------------------------------------------------------------*/
  stringLit = 
    "\"" { stringChar
         | "\\" ( "b" | "t" | "n" | "f" | "r" | "\"" | "\'" | "\\"
                | "u" { "u" } hexDigit hexDigit hexDigit hexDigit
                | zeroToThree [ octalDigit ] [ octalDigit ]
                | octalDigit [ octalDigit ]
                )
         } 
    "\"".

  /*----- keyword names needed in LL(1) resolvers -----*/

  boolean = "boolean".
  byte    = "byte".
  char    = "char".
  class   = "class".
  double  = "double".
  false   = "false".
  final   = "final".
  float   = "float".
  import_ = "import".
  int     = "int".
  long    = "long".
  new     = "new".
  null    = "null".
  public  = "public".
  short   = "short".
  static  = "static".
  super   = "super".
  this    = "this".
  true    = "true".
  void    = "void".
  
  /*----- operators and special characters needed in LL(1) resolvers --------------*/

  colon   = ":".
  comma   = ",".
  dec     = "--".
  dot     = ".".
  inc     = "++".
  lbrace  = "{".
  lbrack  = "[".
  lpar    = "(".
  minus   = "-".
  not     = "!".
  plus    = "+".
  rbrace  = "}".
  rbrack  = "]".
  rpar    = ")".
  tilde   = "~".

COMMENTS FROM "/*" TO "*/"
COMMENTS FROM "//" TO lf

IGNORE lf + cr + tab

/*---------------------------------------------------------------------------*/

PRODUCTIONS

PdeProgram
= { ImportDeclaration<.out importIdent:Array<String>.>	(. context.imports.push(importIdent); .)
    }
  (IF (isJavaProgram()) TypeDeclaration { TypeDeclaration }
    |							(.
							// default imports
							context.imports.push(['xpde', 'core', '*']);
							context.imports.push(['xpde', 'xml', '*']);

							// initialize active program
							classContexts.unshift(new ClassContext(new EnumSet<Modifier>([MPublic]), context.identifier));
							classContexts[0].extend = ['xpde', 'core', 'PApplet'];
							.)
/*    { (IF (isLocalVarDecl(false)) LocalVariableDeclaration) ";" }
    ( IF (isActiveProgram())*/
      ClassBodyDeclaration { ClassBodyDeclaration }
/*      |							(.
//[TODO] this in some graceful manner
							// move field declarations to setup method
							blockContext = FieldDefinable = new BlockContext();
							for (identifier in tempContext.definitions.keys())
							{
								methodContext.definitions.set(identifier, tempContext.definitions.get(identifier));
								tempContext.definitions.remove(identifier);
							}
							
							// initialize setup scope
							blockContexts.unshift(new BlockContext());
							.)
        BlockStatement { BlockStatement }		(.
							// add setup method to class
							var methodContext = new MethodContext(new EnumSet<Modifier>(), null, 'setup');
							methodContext.body = blockContexts.shift().getBlockStatement();
							classContexts[0].methods.push(methodContext);
							.)
      )*/						(.
							// add class
							context.types.push(classContexts.shift());

							// validate script
							if (la.kind != _EOF)
								error("unexpected script termination");
							.)
    )
.

/*---------------------------------------------------------------------------*/

CompilationUnit
= [ "package" Qualident<.out qualident:Array<String>.>	(. context.packageDeclaration = qualident; .)
    ';' ]
  { ImportDeclaration<.out importIdent:Array<String>.>	(. context.imports.push(importIdent); .)
    }
  { TypeDeclaration
    }							(. if (la.kind != _EOF) error("'class' or 'interface' expected"); .)
.

/*---------------------------------------------------------------------------*/

UnparsedSegment<buffer:StringBuf>
= '('								(. buffer.add('('); .)
  { UnparsedSegment<buffer> | ANY				(. buffer.add(t.val); .)
    } ')'							(. buffer.add(')'); .)
| '['								(. buffer.add('['); .)
  { UnparsedSegment<buffer> | ANY				(. buffer.add(t.val); .)
    } ']'							(. buffer.add(']'); .)
| UnparsedBlock<buffer>
| stringLit							(. buffer.add(t.val); .)
.

UnparsedBlock<buffer:StringBuf>
= '{'								(. buffer.add('{'); .)
  { UnparsedSegment<buffer> | ANY				(. buffer.add(t.val); .)
    } '}'							(. buffer.add('}'); .)
.

UnparsedExpression<buffer:StringBuf>
= { UnparsedSegment<buffer> | ANY				(. buffer.add(t.val); .)
    } ';'
.

/*---------------------------------------------------------------------------*/

Qualident<.out qualident:Array<String>.>		(. qualident = []; .)
= ident							(. qualident.push(t.val); .)
  { '.' ident						(. qualident.push(t.val); .)
    }
.

/*---------------------------------------------------------------------------*/

ImportDeclaration<.out importIdent:Array<String>.>
= "import" ident					(. importIdent = [t.val]; .)
  QualifiedImport<.out arg:Array<String>.> ';'		(. importIdent = importIdent.concat(arg); .)
.

/*---------------------------------------------------------------------------*/

QualifiedImport<.out importIdent:Array<String>.>
= "." (ident						(. importIdent = [t.val]; .)
        [QualifiedImport<. out arg:Array<String>.>	(. importIdent = importIdent.concat(arg); .)
	  ] | "*"					(. importIdent = ['*']; .) 
          )
.

/*---------------------------------------------------------------------------*/

TypeDeclaration
= ClassOrInterfaceDeclaration<out typeContext:TypeContext>	(. context.types.push(typeContext); .)
| ";"
.

/*---------------------------------------------------------------------------*/

ClassOrInterfaceDeclaration<out typeContext:TypeContext>	(. var modifiers = new EnumSet<Modifier>(); .) 
= { ClassModifier<modifiers> } 
  ( ClassDeclaration<out arg:TypeContext, modifiers>		(. typeContext = arg; .)
    | InterfaceDeclaration<out arg:TypeContext, modifiers>	(. typeContext = arg; .)
  )
.

/*---------------------------------------------------------------------------*/

ClassModifier<.modifiers:EnumSet<Modifier>.>
= "public"						(. addModifier(modifiers, MPublic); .)
| "protected"						(. addModifier(modifiers, MProtected); .)
| "private"						(. addModifier(modifiers, MPrivate); .)
| "abstract"						(. addModifier(modifiers, MAbstract); .)
| "static"						(. addModifier(modifiers, MStatic); .)
| "final"						(. addModifier(modifiers, MFinal); .)
| "strictfp"						(. addModifier(modifiers, MStrictfp); .)
.

/*---------------------------------------------------------------------------*/

Modifier0<.modifiers:EnumSet<Modifier>.>
= "static"						(. addModifier(modifiers, MStatic); .)
|  Modifier1<modifiers>
.

/*---------------------------------------------------------------------------*/

Modifier1<.modifiers:EnumSet<Modifier>.>
= "public"						(. addModifier(modifiers, MPublic); .)
| "protected"						(. addModifier(modifiers, MProtected); .)
| "private"						(. addModifier(modifiers, MPrivate); .)
| "abstract"						(. addModifier(modifiers, MAbstract); .)
| "final"						(. addModifier(modifiers, MFinal); .)
| "native"						(. addModifier(modifiers, MNative); .)
| "synchronized"					(. addModifier(modifiers, MSynchronized); .)
| "transient"						(. addModifier(modifiers, MTransient); .)
| "volatile"						(. addModifier(modifiers, MVolatile); .)
| "strictfp"						(. addModifier(modifiers, MStrictfp); .)
.

/*---------------------------------------------------------------------------*/

Type<out type:ParserDataType>				/* TODO: qualifier MAY be a local class, an inner class, or a top-level import */
= ( Qualident<.out qualident:Array<String>.>		(. type = PReference(qualident); .)
  | BasicType<out primitive:PrimitiveType>		(. type = PPrimitive(primitive); .) 
  ) BracketsOpt<out bCount:Int>				(. if (bCount > 0) type = PArray(type, bCount); .)
.

/*---------------------------------------------------------------------------*/

BasicType<out type:PrimitiveType>
= "byte"						(. type = PTByte; .)
| "short"						(. type = PTShort; .)
| "char"						(. type = PTChar; .)
| "int"							(. type = PTInt; .)
| "long"						(. type = PTLong; .)
| "float"						(. type = PTFloat; .)
| "double"						(. type = PTDouble; .)
| "boolean"						(. type = PTBoolean; .)
.

/*---------------------------------------------------------------------------*/

BracketsOpt<out bCount:Int>				(. bCount = 0; .)
= { "[" "]"						(. bCount++; .)
    }
.

/*---------------------------------------------------------------------------*/
/*
QualidentList<.out list:Array<Array<String>>.>		(. list = []; .)	
= Qualident<out arg:Array<String>.>				(. list.push(type); .)
  { "," Qualident<out type:ParserDataType>				(. list.push(type); .)
    }
.
*/
/*---------------------------------------------------------------------------*/

/*
FormalParameter0<out parameter:FormalParameter>
= [ "final" ] Type<out type:ParserDataType> VariableDeclaratorId
.*/

FormalParameter0<out parameter:FormalParameterContext>	(. var modifiers = new EnumSet<Modifier>(); .)
= [ "final"						(. modifiers.add(MFinal); .)
    ] Type<out type:ParserDataType> ident		(. var identifier:String = t.val; .)
  BracketsOpt<out bCount:Int>				(. if (bCount > 0) type = PArray(type, bCount); .)
							(. parameter = new FormalParameterContext(modifiers, type, identifier); .)
.

/*---------------------------------------------------------------------------*/

QualidentList<.out list:Array<Array<String>>.>		(. list = []; .)
= Qualident<.out qualident:Array<String>.>		(. list.push(qualident); .)
  { "," Qualident<.out qualident:Array<String>.>	(. list.push(qualident); .)
    }
.

/*---------------------------------------------------------------------------*/

VariableDeclarator<.out context:FieldContext, modifiers:EnumSet<Modifier>, type:ParserDataType.>
= ident							(. context = new FieldContext(modifiers, type, t.val); .)
  VariableDeclaratorRest<context>
.

/*---------------------------------------------------------------------------*/

/*
VariableDeclaratorId
= ident BracketsOpt
.*/

/*---------------------------------------------------------------------------*/

VariableDeclaratorRest<context:FieldContext>
= BracketsOpt<out bCount:Int>				(. if (bCount > 0) context.type = PArray(context.type, bCount); .)
  [ "="
    UnparsedExpression<new StringBuf()>
    /* VariableInitializer<out expression:Expression>	(. context.initialization = expression; .) */
    ]
.

/*---------------------------------------------------------------------------*
 *---------------------------- Classes --------------------------------------*
 *---------------------------------------------------------------------------*/

ClassDeclaration<.out typeContext:TypeContext, modifiers:EnumSet<Modifier>.>
= 							(. checkModifierPermission(modifiers, ModifierSet.classes); .)
  "class" ident						(. classContexts.unshift(new ClassContext(modifiers, t.val, classContexts[0])); .)
  [ "extends" Qualident<.out arg:Array<String>.>	(. classContexts[0].extend = arg; .)
    ]
  [ "implements" QualidentList<.out arg:Array<Array<String>>.>	(. classContexts[0].implement = arg; .)
    ]
  ClassBody						(. typeContext = classContexts.shift(); .)
.

/*---------------------------------------------------------------------------*/

ClassBody
= "{" { ClassBodyDeclaration	
        } "}"
.

/*---------------------------------------------------------------------------*/

ClassBodyDeclaration
= ";"
|							(. var modifiers = new EnumSet<Modifier>(); .)
  ["static"						(. addModifier(modifiers, MStatic); .)
  ] ( UnparsedSegment<new StringBuf()>
      /*Block<out block:Statement, null>			(. classContexts[0].staticConstructor.pushStatement(block); .)*/
      | [ Modifier1<modifiers> { Modifier0<modifiers> } ] MemberDecl<modifiers>
      )
.

/*---------------------------------------------------------------------------*/

MemberDecl<.modifiers:EnumSet<Modifier>.>
= IF (identAndLPar()) ident				(. var identifier:String = t.val;
							   // validate constructor name
							   if (identifier != classContexts[0].identifier) error('invalid function declaration'); .)
  ConstructorDeclaratorRest<new MethodContext(modifiers, null, identifier)>
| MethodOrFieldDecl<modifiers>
|							(. checkModifierPermission(modifiers, ModifierSet.methods); .)
  "void" ident						(. var identifier:String = t.val; .)
  VoidMethodDeclaratorRest<new MethodContext(modifiers, null, identifier)>
| ClassDeclaration<out typeContext:TypeContext, modifiers>	(. classContexts[0].types.push(typeContext); .)
| InterfaceDeclaration<out typeContext:TypeContext, modifiers>	(. classContexts[0].types.push(typeContext); .)
.

/*---------------------------------------------------------------------------*/

MethodOrFieldDecl<.modifiers:EnumSet<Modifier>.>
= Type<out type:ParserDataType> ident				(. var identifier:String = t.val; .)
  MethodOrFieldRest<modifiers, identifier, type>
.

/*---------------------------------------------------------------------------*/

MethodOrFieldRest<.modifiers:EnumSet<Modifier>, identifier:String, type:ParserDataType.>
=							(. checkModifierPermission(modifiers, ModifierSet.fields);  .) 
  VariableDeclaratorsRest<modifiers, type, identifier> ';'
|							(. checkModifierPermission(modifiers, ModifierSet.methods); .)
  MethodDeclaratorRest<new MethodContext(modifiers, type, identifier)>
.

/*---------------------------------------------------------------------------*/

VariableDeclaratorsRest<.modifiers:EnumSet<Modifier>, type:ParserDataType, identifier:String.>
=									(. var context = new FieldContext(modifiers, type, identifier); .)
  VariableDeclaratorRest<context>					(. classContexts[0].fields.push(context); .)
  {',' VariableDeclarator<out context:FieldContext, modifiers, type>	(. classContexts[0].fields.push(context); .)
    }
.

/*---------------------------------------------------------------------------*/

MethodDeclaratorRest<.methodContext:MethodContext.>
= FormalParameters<.out arg:Array<FormalParameterContext>.>	(. methodContext.parameters = arg; .)
  BracketsOpt<out bCount:Int>					/*[TODO] lolwhut */
  [ "throws" QualidentList<.out arg:Array<Array<String>>.>	(. methodContext.throwsList = arg; .)
    ]
  (								(. var buffer:StringBuf = new StringBuf(); .)
    UnparsedBlock<buffer>					(. trace(buffer); .)
  /*Block<out block:Statement, methodContext>			(. methodContext.body = block; .)*/
  | ";"
  )								(. classContexts[0].methods.push(methodContext); .)
.

/*---------------------------------------------------------------------------*/

VoidMethodDeclaratorRest<.methodContext:MethodContext.>
= FormalParameters<.out arg:Array<FormalParameterContext>.>	(. methodContext.parameters = arg; .) 
  [ "throws" QualidentList<.out arg:Array<Array<String>>.>	(. methodContext.throwsList = arg; .)
    ]
  (								(. var buffer:StringBuf = new StringBuf(); .)
    UnparsedBlock<buffer>					(. trace(buffer); .)
    /*Block<out block:Statement, methodContext>			(. methodContext.body = block; .)*/
    | ';')							(. classContexts[0].methods.push(methodContext); .)
.

/*---------------------------------------------------------------------------*/

ConstructorDeclaratorRest<.methodContext:MethodContext.>
=								(. checkModifierPermission(methodContext.modifiers, ModifierSet.constructors); .)
  FormalParameters<.out arg:Array<FormalParameterContext>.>	(. methodContext.parameters = arg; .)
  [ "throws" QualidentList<.out arg:Array<Array<String>>.>	(. methodContext.throwsList = arg; .)
    ]
  UnparsedBlock<new StringBuf()>
  /*Block<out body:Statement, methodContext>*/			(. classContexts[0].methods.push(methodContext); .)
.

/*---------------------------------------------------------------------------*/

FormalParameters<.out parameters:Array<FormalParameterContext>.>	(. parameters = []; .)
= "(" [ FormalParameter0<out parameter:FormalParameterContext>		(. parameters.push(parameter); .)
        { "," FormalParameter0<out parameter:FormalParameterContext>	(. parameters.push(parameter); .)
	  } ] ")"
.

/*---------------------------------------------------------------------------*
 *---------------------------- Interfaces -----------------------------------*
 *---------------------------------------------------------------------------*/

InterfaceDeclaration<.out typeContext:TypeContext, modifiers:EnumSet<Modifier>.>
=							(. checkModifierPermission(modifiers, ModifierSet.interfaces); .)
  "interface" ident [ "extends" QualidentList<.out extend:Array<Array<String>>.> ] InterfaceBody
.

/*---------------------------------------------------------------------------*/

InterfaceBody
= "{" { InterfaceBodyDeclaration } "}"
.

/*---------------------------------------------------------------------------*/

InterfaceBodyDeclaration				(. var modifiers = new EnumSet<Modifier>(); .) 
= ";"
| { Modifier0<modifiers> } InterfaceMemberDecl<modifiers>
.

/*---------------------------------------------------------------------------*/

InterfaceMemberDecl<.modifiers:EnumSet<Modifier>.>
= InterfaceMethodOrFieldDecl<modifiers>
|							(. checkModifierPermission(modifiers, ModifierSet.interfaces); .)
  "void" ident VoidInterfaceMethodDeclaratorRest
| ClassDeclaration<out typeContext:TypeContext, modifiers>
| InterfaceDeclaration<out typeContext:TypeContext, modifiers>
.

/*---------------------------------------------------------------------------*/

InterfaceMethodOrFieldDecl<.modifiers:EnumSet<Modifier>.>
= Type<out type:ParserDataType> ident InterfaceMethodOrFieldRest<modifiers>
.

/*---------------------------------------------------------------------------*/

InterfaceMethodOrFieldRest<.modifiers:EnumSet<Modifier>.>
=							(. checkModifierPermission(modifiers, ModifierSet.constants);  .) 
  ConstantDeclaratorsRest ";"
|							(. checkModifierPermission(modifiers, ModifierSet.interfaces); .) 
  InterfaceMethodDeclaratorRest
.

/*---------------------------------------------------------------------------*/

ConstantDeclaratorsRest
= ConstantDeclaratorRest { "," ConstantDeclarator }
.

/*---------------------------------------------------------------------------*/

ConstantDeclaratorRest
= BracketsOpt<out bCount:Int> "=" UnparsedExpression<new StringBuf()>
  /* VariableInitializer<out expression:Expression> */
.

/*---------------------------------------------------------------------------*/

ConstantDeclarator
= ident ConstantDeclaratorRest
.

/*---------------------------------------------------------------------------*/

InterfaceMethodDeclaratorRest
= FormalParameters<.out parameters:Array<FormalParameterContext>.> BracketsOpt<out bCount:Int> [ "throws" QualidentList<.out arg:Array<Array<String>>.>] ";"
.

/*---------------------------------------------------------------------------*/

VoidInterfaceMethodDeclaratorRest
= FormalParameters<.out parameters:Array<FormalParameterContext>.> [ "throws" QualidentList<.out arg:Array<Array<String>>.>] ";"
.

END PdeProgram.
