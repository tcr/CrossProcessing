import xpde.parser.Scanner;
import xpde.parser.Syntax;

COMPILER CompilationUnit

public var compilationUnit:CompilationUnit;
  
/*---------------------------- token sets -----------------------------------*/

static var maxTerminals:Int = 160;  // set size

static function newSet(values:Array<Int>):BitSet {
  var s:BitSet = new BitSet(maxTerminals);
  for (i in 0...values.length) s.set(values[i]);
  return s;
}

static function or(s1:BitSet, s2:BitSet):BitSet {
  s1.or(s2);
  return s1;
}

static var typeKWarr:Array<Int> = [_byte, _short, _char, _int, _long, _float, _double, 
                          _boolean];
static var castFollowerArr:Array<Int> = [_ident, _new, _super, _this, _void, _intLit,
                                _floatLit, _charLit, _stringLit, _true, _false,
                                _null, _lpar, _not, _tilde];
static var prefixArr:Array<Int> = [_inc, _dec, _not, _tilde, _plus, _minus];                                

static var typeKW:BitSet       = newSet(typeKWarr);
static var castFollower:BitSet = or(newSet(castFollowerArr), typeKW);
static var prefix:BitSet       = newSet(prefixArr);

/*---------------------------- auxiliary methods ----------------------------*/

public function error (s:String):Void {
  if (errDist >= minErrDist) errors.SemErr(la.line, la.col, s);
  errDist = 0;
}

// "(" BasicType {"[""]"} ")"
function isSimpleTypeCast ():Bool {
  // assert: la.kind == _lpar
  scanner.ResetPeek();
  var pt1:Token = scanner.Peek();
  
  if (typeKW.get(pt1.kind)) {
    var pt:Token = scanner.Peek();
    pt = skipDims(pt);
    if (pt != null) {
      return pt.kind == _rpar;
    }
  }
  return false;
}

// "(" Qualident {"[" "]"} ")" castFollower
function guessTypeCast ():Bool {
  // assert: la.kind == _lpar
  scanner.ResetPeek();
  var pt:Token = scanner.Peek();
  pt = rdQualident(pt);
  if (pt != null) {
    pt = skipDims(pt);
    if (pt != null) {
      var pt1:Token = scanner.Peek();
      return pt.kind == _rpar && castFollower.get(pt1.kind);
    }
  }
  return false;
}

// "[" "]"
function skipDims (pt:Token):Token {
  if (pt.kind != _lbrack) return pt;
  do {
     pt = scanner.Peek();
    if (pt.kind != _rbrack) return null;
     pt = scanner.Peek();
  } while (pt.kind == _lbrack);  
  return pt;
}

/* Checks whether the next sequence of tokens is a qualident *
 * and returns the qualident string                          *
 * !!! Proceeds from current peek position !!!               */
function rdQualident (pt:Token):Token {
  var qualident:String = "";
  
  if (pt.kind == _ident) {
    qualident = pt.val;
    pt = scanner.Peek();
    while (pt.kind == _dot) {
      pt = scanner.Peek();
      if (pt.kind != _ident) return null;
      qualident += "." + pt.val;
      pt = scanner.Peek();
    }
    return pt;
  } else return null;
}

// Return the n-th token after the current lookahead token
function peek(n:Int):Token {
  scanner.ResetPeek();
  var x:Token = la;
  while (n > 0) { x = scanner.Peek(); n--; }
  return x;
}


function checkExprStat(expression:Expression):Void {
	switch (expression)
	{
	    case ECall(_, _, _):
	    case EObjectInstantiation(_, _):
	    case EAssignment(_, _, _):
	    case EPrefix(_, _):
	    case EPostfix(_, _):
	    default: error("not a statement" + " (" + expression + ")");
	}
}

/*-----------------------------------------------------------------*
 * Resolver routines to resolve LL(1) conflicts:                   *
 * These routines return a boolean value that indicates            *
 * whether the alternative at hand shall be choosen or not.        *
 * They are used in IF ( ... ) expressions.                        *       
 *-----------------------------------------------------------------*/

// ',' (no '}')
function commaAndNoRBrace():Bool {
  return (la.kind == _comma && peek(1).kind != _rbrace);
}

// '.' ident
function dotAndIdent():Bool {
  return la.kind == _dot && peek(1).kind == _ident;
}

// ident '('
function identAndLPar ():Bool {
  return la.kind == _ident && peek(1).kind == _lpar;
}

// ident ':'
function isLabel():Bool {
  return la.kind == _ident && peek(1).kind == _colon;
}

// '[' (no ']')
function nonEmptyBracket():Bool {
  return (la.kind == _lbrack && peek(1).kind != _rbrack);
}

// '['']'
function emptyBracket():Bool {
  return (la.kind == _lbrack && peek(1).kind == _rbrack);
}

// final or Type ident
function isLocalVarDecl(finalIsSuccess:Bool):Bool {
  var pt:Token = la;
  scanner.ResetPeek();
  
  if (la.kind == _final) 
    if (finalIsSuccess) return true;
    else pt = scanner.Peek();

  // basicType | ident
  if (typeKW.get(pt.kind))
    pt = scanner.Peek();
  else
    pt = rdQualident(pt);
    
  if (pt != null) {
    pt = skipDims(pt);
    if (pt != null) {
      return pt.kind == _ident;
    }
  }
  return false;
}

function isTypeCast():Bool {
  if (la.kind != _lpar) return false;
  if (isSimpleTypeCast()) return true;
  return guessTypeCast();
}

// '.' ("super" '.' | "class" | "this") | '(' | '['']'
function isIdentSuffix():Bool {
  if (la.kind == _dot) {
    scanner.ResetPeek();
    var pt:Token = scanner.Peek();
    if (pt.kind == _super) return scanner.Peek().kind == _dot;
    return (pt.kind == _class || pt.kind == _this);
  }
  return (la.kind == _lpar || emptyBracket());
}

/*-------------------------------------------------------------------------*/

CHARACTERS
  tab           = '\u0009'. /*  9 = tabulator */
  lf            = '\u000a'. /* 10 = line feed */
  cr            = '\u000d'. /* 13 = carriage return */

  zero          = '0'.
  zeroToThree   = zero + "123" .
  octalDigit    = zero + "1234567" . 
  nonZeroDigit  = "123456789".
  digit         = '0' + nonZeroDigit .
  hexDigit      = digit + "ABCDEFabcdef" .
  letter        = 'A' .. 'Z' + 'a' .. 'z' + '_' + '$'.

  char          = ANY - "'" - '\\' - cr - lf.
  stringChar    = ANY - "\"" - '\\' - cr - lf.

TOKENS
  ident         = letter { letter | digit }.
  /*-------------------------------------------------------------------------*/
  intLit = 
  (  zero | nonZeroDigit { digit }
  | ( "0x" | "0X" ) hexDigit { hexDigit }
  | '0' octalDigit { octalDigit }
  ) [ "l" | "L" ].
  /*-------------------------------------------------------------------------*/
  floatLit =
    "." digit {digit} 
    [("e" | "E") ["+" | "-"] digit {digit}] 
    [ "F" | "f" | "D" | "d" ]
  | digit {digit} 
    ( "." {digit} 
      [("e" | "E" ) ["+" | "-"] digit {digit} ] 
      [ "F" | "f" | "D" | "d" ]
    | ("e" | "E") ["+" | "-"] digit {digit}
      [ "F" | "f" | "D" | "d" ]
    | "F" | "f" | "D" | "d"
    ).  
  /*-------------------------------------------------------------------------*/
  charLit = 
    "'" ( char
        | "\\" ( "b" | "t" | "n" | "f" | "r" | "\"" | "\'" | "\\"
               | "u" { "u" } hexDigit hexDigit hexDigit hexDigit
               | zeroToThree [ octalDigit ] [ octalDigit ]
               | octalDigit [ octalDigit ]
               )
        ) 
    "'".
  /*-------------------------------------------------------------------------*/
  stringLit = 
    "\"" { stringChar
         | "\\" ( "b" | "t" | "n" | "f" | "r" | "\"" | "\'" | "\\"
                | "u" { "u" } hexDigit hexDigit hexDigit hexDigit
                | zeroToThree [ octalDigit ] [ octalDigit ]
                | octalDigit [ octalDigit ]
                )
         } 
    "\"".

  /*----- keyword names needed in LL(1) resolvers -----*/

  boolean = "boolean".
  byte    = "byte".
  char    = "char".
  class   = "class".
  double  = "double".
  false   = "false".
  final   = "final".
  float   = "float".
  int     = "int".
  long    = "long".
  new     = "new".
  null    = "null".
  short   = "short".
  static  = "static".
  super   = "super".
  this    = "this".
  true    = "true".
  void    = "void".
  
  /*----- operators and special characters needed in LL(1) resolvers --------------*/

  colon   = ":".
  comma   = ",".
  dec     = "--".
  dot     = ".".
  inc     = "++".
  lbrace  = "{".
  lbrack  = "[".
  lpar    = "(".
  minus   = "-".
  not     = "!".
  plus    = "+".
  rbrace  = "}".
  rbrack  = "]".
  rpar    = ")".
  tilde   = "~".

COMMENTS FROM "/*" TO "*/"
COMMENTS FROM "//" TO lf

IGNORE lf + cr + tab

/*---------------------------------------------------------------------------*/

PRODUCTIONS

CompilationUnit<out script:ScriptScope>			(.
							// create compilation unit
							compilationUnit = {
							    packageIdent: [],
							    importIdents: [],
							    definitions: new Hash<Definition>()
							};
							// script scope
							script = new ScriptScope();
							.)
= [ "package" Qualident<.out qualident:Array<String>.> (. compilationUnit.packageIdent = qualident; .)
    ';' ]
  { ImportDeclaration<.out importIdent:Array<String>.>	(. compilationUnit.importIdents.push(importIdent); .)
    }
  { TypeDeclaration<script>				(. compilationUnit.definitions = script.getDefinitions(); .)
    }							(. if (la.kind != _EOF) error("'class' or 'interface' expected"); .)
.

/*---------------------------------------------------------------------------*/

Qualident<.out qualident:Array<String>.>		(. qualident = []; .)
= ident							(. qualident.push(t.val); .)
  { '.' ident						(. qualident.push(t.val); .)
    }
.

/*---------------------------------------------------------------------------*/

ImportDeclaration<.out importIdent:Array<String>.>
= "import" ident					(. importIdent = [t.val]; .)
  QualifiedImport<.out idents:Array<String>.> ';'	(. importIdent = importIdent.concat(idents); .)
.

/*---------------------------------------------------------------------------*/

QualifiedImport<.out idents:Array<String>.>
= "." (ident						(. idents = [t.val]; .)
        [QualifiedImport<. out idents_:Array<String>.>	(. idents = idents.concat(idents_); .)
	  ] | "*"					(. idents = ['*']; .) 
          )
.

/*---------------------------------------------------------------------------*/

TypeDeclaration<scope:Scope>
= ClassOrInterfaceDeclaration<scope>
| ";"
.

/*---------------------------------------------------------------------------*/

ClassOrInterfaceDeclaration<scope:Scope>		(. var m:Modifiers = new Modifiers(this); .) 
= { ClassModifier<m> } 
  ( ClassDeclaration<scope, m>
  |  InterfaceDeclaration<scope, m>
  )
.

/*---------------------------------------------------------------------------*/

ClassModifier<m:Modifiers>
= "public"						(. m.add(Modifier._public);    .)
| "protected"						(. m.add(Modifier._protected); .)
| "private"						(. m.add(Modifier._private);   .)
| "abstract"						(. m.add(Modifier._abstract);  .)
| "static"						(. m.add(Modifier._static);    .)
| "final"						(. m.add(Modifier._final);     .)
| "strictfp"						(. m.add(Modifier._strictfp);  .)
.

/*---------------------------------------------------------------------------*/

Modifier0<m:Modifiers>
= "static"						(. m.add(Modifier._static);    .)
|  Modifier1<m>
.

/*---------------------------------------------------------------------------*/

Modifier1<m:Modifiers>
= "public"						(. m.add(Modifier._public);      .)
| "protected"						(. m.add(Modifier._protected);   .)
| "private"						(. m.add(Modifier._private);     .)
| "abstract"						(. m.add(Modifier._abstract);    .)
| "final"						(. m.add(Modifier._final);       .)
| "native"						(. m.add(Modifier._native);      .)
| "synchronized"					(. m.add(Modifier._synchronized);.)
| "transient"						(. m.add(Modifier._transient);   .)
| "volatile"						(. m.add(Modifier._volatile);    .)
| "strictfp"						(. m.add(Modifier._strictfp);    .)
.

/*---------------------------------------------------------------------------*/

Type<out type:DataType>
= ( Qualident<.out qualident:Array<String>.>		(. type = DTReference(qualident); .)
  | BasicType<out primitive:PrimitiveType>		(. type = DTPrimitive(primitive); .) 
  ) BracketsOpt						(. /* TODO */ .)
.

/*---------------------------------------------------------------------------*/

BasicType<out type:PrimitiveType>
= "byte"						(. type = PTByte; .)
| "short"						(. type = PTShort; .)
| "char"						(. type = PTChar; .)
| "int"							(. type = PTInt; .)
| "long"						(. type = PTLong; .)
| "float"						(. type = PTFloat; .)
| "double"						(. type = PTDouble; .)
| "boolean"						(. type = PTBoolean; .)
.

/*---------------------------------------------------------------------------*/

BracketsOpt
= { "[" "]" }
.

/*---------------------------------------------------------------------------*/

TypeList<.out list:Array<DataType>.>			(. list = []; .)	
= Type<out type:DataType>				(. list.push(type); .)
  { "," Type<out type:DataType>				(. list.push(type); .)
    }
.

/*---------------------------------------------------------------------------*/

FormalParameter0<out parameter:FormalParameter>
= [ "final" ] Type<out type:DataType> VariableDeclaratorId
.

/*---------------------------------------------------------------------------*/

QualidentList						(. var list:Array<Array<String>> = []; .)
= Qualident<.out qualident:Array<String>.>		(. list.push(qualident); .)
  { "," Qualident<.out qualident:Array<String>.>	(. list.push(qualident); .)
    }
.

/*---------------------------------------------------------------------------*/

VariableDeclarator
= ident VariableDeclaratorRest
.

/*---------------------------------------------------------------------------*/

VariableDeclaratorId
= ident BracketsOpt
.

/*---------------------------------------------------------------------------*/

VariableDeclaratorRest
= BracketsOpt [ "=" VariableInitializer ]
.

/*---------------------------------------------------------------------------*/

VariableInitializer
= ArrayInitializer
| Expression0<out dummy:Expression>
.

/*---------------------------------------------------------------------------*
 *---------------------------- Classes --------------------------------------*
 *---------------------------------------------------------------------------*/

ClassDeclaration<scope:Scope, m:Modifiers>
= 							(. m.check(Modifier.classes); .)
  "class" ident						(. var identifier:String = t.val, extend:DataType = null, implement:Array<DataType> = null; .)
  [ "extends" Type<out arg:DataType> 			(. extend = arg; .)
    ]
  [ "implements" TypeList<.out arg:Array<DataType>.>	(. implement = arg; .)
    ]
  ClassBody<.out definitions:Hash<Definition>.>	(. scope.define(identifier, DClass(identifier, m, definitions, extend, implement)); .)
.

/*---------------------------------------------------------------------------*/

ClassBody<.out definitions:Hash<Definition>.>		(. var classScope:ClassScope = new ClassScope(); .)
= "{" { ClassBodyDeclaration<classScope>	
        } "}"						(. definitions = classScope.getDefinitions(); .)
.

/*---------------------------------------------------------------------------*/

ClassBodyDeclaration<scope:ClassScope>
= ";"
|							(. var m:Modifiers = new Modifiers(this); .)
  ["static"						(. m.add(Modifier._static);           .)
  ] ( Block<out block:Statement, null>			(. /* TODO */ .)
    | [ Modifier1<m> { Modifier0<m> } ] MemberDecl<scope, m>
    )
.

/*---------------------------------------------------------------------------*/

MemberDecl<scope:ClassScope, m:Modifiers>
= IF (identAndLPar()) ident				(. var identifier:String = t.val; .) /* TODO: check constructor name == ident name */
  ConstructorDeclaratorRest<scope, m, identifier>
| MethodOrFieldDecl<scope, m>
|							(. m.check(Modifier.methods); .)
  "void" ident						(. var identifier:String = t.val; .)
  VoidMethodDeclaratorRest<scope, m, identifier>
| ClassDeclaration<scope, m>
| InterfaceDeclaration<scope, m>
.

/*---------------------------------------------------------------------------*/

MethodOrFieldDecl<scope:ClassScope, m:Modifiers>
= Type<out type:DataType> ident				(. var identifier:String = t.val; .)
  MethodOrFieldRest<scope, m, identifier, type>
.

/*---------------------------------------------------------------------------*/

MethodOrFieldRest<scope:ClassScope, m:Modifiers, identifier:String, type:DataType>
=							(. m.check(Modifier.fields);  .) 
  VariableDeclaratorsRest ';'
|							(. m.check(Modifier.methods); .)
  MethodDeclaratorRest<scope, m, identifier, type>
.

/*---------------------------------------------------------------------------*/

VariableDeclaratorsRest
= VariableDeclaratorRest {',' VariableDeclarator}
.

/*---------------------------------------------------------------------------*/

ArrayInitializer
= "{" [ VariableInitializer 
        { IF (commaAndNoRBrace()) "," VariableInitializer }       
      ] [ "," ] 
  "}"
.

/*---------------------------------------------------------------------------*/

MethodDeclaratorRest<scope:ClassScope, m:Modifiers, identifier:String, type:DataType>
=							(. var body:Statement = null; .)
  FormalParameters<.out parameters:Array<FormalParameter>.>
  BracketsOpt [ "throws" QualidentList]
  ( Block<out block:Statement, null>			(. body = block; .)
  | ";"
  )							(. scope.define(identifier, DMethod(identifier, type, m, parameters, body)); .)
.

/*---------------------------------------------------------------------------*/

VoidMethodDeclaratorRest<scope:ClassScope, m:Modifiers, identifier:String>
=							(. var body:Statement = null; .)
  FormalParameters<.out parameters:Array<FormalParameter>.>
  ["throws" QualidentList]
  (Block<out block:Statement, null>			(. body = block; .)
    | ';')						(. scope.define(identifier, DMethod(identifier, null, m, parameters, body)); .)
.

/*---------------------------------------------------------------------------*/

ConstructorDeclaratorRest<scope:ClassScope, m:Modifiers, identifier:String>
=							(. m.check(Modifier.constructors);
							   var throwsList:Array<Array<String>> = []; .)
  FormalParameters<.out parameters:Array<FormalParameter>.>
  [ "throws" QualidentList ]
  Block<out body:Statement, null>			(. scope.define(identifier, DMethod(identifier, null, m, parameters, body)); .)
.

/*---------------------------------------------------------------------------*/

FormalParameters<.out parameters:Array<FormalParameter>.>	(. parameters = []; .)
= "(" [ FormalParameter0<out parameter:FormalParameter>		(. parameters.push(parameter); .)
        { "," FormalParameter0<out parameter:FormalParameter>	(. parameters.push(parameter); .)
	  } ] ")"
.

/*---------------------------------------------------------------------------*
 *---------------------------- Interfaces -----------------------------------*
 *---------------------------------------------------------------------------*/

InterfaceDeclaration<scope:Scope, m:Modifiers>
=							(. m.check(Modifier.interfaces); .)
  "interface" ident [ "extends" TypeList<.out extend:Array<DataType>.> ] InterfaceBody
.

/*---------------------------------------------------------------------------*/

InterfaceBody
= "{" { InterfaceBodyDeclaration } "}"
.

/*---------------------------------------------------------------------------*/

InterfaceBodyDeclaration				(. var m:Modifiers = new Modifiers(this); .) 
= ";"
| { Modifier0<m> } InterfaceMemberDecl<m>
.

/*---------------------------------------------------------------------------*/

InterfaceMemberDecl<m:Modifiers>
= InterfaceMethodOrFieldDecl<m>
|							(. m.check(Modifier.interfaces); .)
  "void" ident VoidInterfaceMethodDeclaratorRest
| ClassDeclaration<null, m>
| InterfaceDeclaration<null, m>
.

/*---------------------------------------------------------------------------*/

InterfaceMethodOrFieldDecl<m:Modifiers>
= Type<out type:DataType> ident InterfaceMethodOrFieldRest<m>
.

/*---------------------------------------------------------------------------*/

InterfaceMethodOrFieldRest<m:Modifiers>
=							(. m.check(Modifier.constants);  .) 
  ConstantDeclaratorsRest ";"
|							(. m.check(Modifier.interfaces); .) 
  InterfaceMethodDeclaratorRest
.

/*---------------------------------------------------------------------------*/

ConstantDeclaratorsRest
= ConstantDeclaratorRest { "," ConstantDeclarator }
.

/*---------------------------------------------------------------------------*/

ConstantDeclaratorRest
= BracketsOpt "=" VariableInitializer
.

/*---------------------------------------------------------------------------*/

ConstantDeclarator
= ident ConstantDeclaratorRest
.

/*---------------------------------------------------------------------------*/

InterfaceMethodDeclaratorRest
= FormalParameters<.out parameters:Array<FormalParameter>.> BracketsOpt [ "throws" QualidentList] ";"
.

/*---------------------------------------------------------------------------*/

VoidInterfaceMethodDeclaratorRest
= FormalParameters<.out parameters:Array<FormalParameter>.> [ "throws" QualidentList] ";"
.

/*---------------------------------------------------------------------------*
 *---------------------------- Statements -----------------------------------*
 *---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/

Statement0<out statement:Statement, scope:BlockScope>
= Block<out block:Statement, scope>			(. statement = block; .)
| "if" ParExpression<out condition:Expression>
   Statement0<out thenStatement:Statement, scope>	(. var elseStatement:Statement = null; .)
   [ "else" Statement0<out body:Statement, scope>	(. elseStatement = body; .)
     ]							(. statement = SConditional(condition, thenStatement, elseStatement); .)
| "for" "("						(. var forScope:BlockScope = new BlockScope(scope); .)
  [ ForInit<forScope> ] ";"				(. var conditional:Expression = EBooleanLiteral(true); .)
  [ Expression0<out expression:Expression>		(. conditional = expression; .)
    ] ";"						(. var updateScope:BlockScope = new BlockScope(scope); .)
  [ ForUpdate<updateScope> ] ")"
  Statement0<out body:Statement, scope>			(. forScope.pushStatement(SLoop(conditional, body, false));
							   forScope.concat(updateScope);
							   statement = forScope.getStatement(); .)
| "while" ParExpression<out condition:Expression>
  Statement0<out body:Statement, scope>			(. statement = SLoop(condition, body, false); .)
| "do" Statement0<out body:Statement, scope>
  "while" ParExpression<out condition:Expression> ";"	(. statement = SLoop(condition, body, true); .)
| "try" Block<out body:Statement, scope>		(. var catches:Array<Catch> = [], finallyBody:Statement = null; .)
  ( Catches<.out _catches:Array<Catch>, scope.>	(. catches = _catches; .)
    [ "finally" Block<out block:Statement, scope>	(. finallyBody = block; .)
      ]
    | "finally" Block<out block:Statement, scope>	(. finallyBody = block; .)
      )							(. statement = STry(body, catches, finallyBody); .)
| "switch" ParExpression<out expression:Expression> '{' SwitchBlockStatementGroups '}' /* TODO */
| "synchronized" ParExpression<out expression:Expression>
  Block<out block:Statement, null>			/* TODO */
| "return"						(. var value:Expression = null; .)
  [ Expression0<out expression:Expression>		(. value = expression; .)
    ] ";"						(. statement = SReturn(value); .)
| "throw" Expression0<out expression:Expression> ";"	/* TODO */
| "break"						(. var label:String = null; .)
  [ ident						(. label = t.val; .)
    ] ';'						(. statement = SBreak(label); .)
| "continue"						(. var label:String = null; .)
  [ ident						(. label = t.val; .)
    ] ';'						(. statement = SContinue(label); .)
| ";"
| IF (isLabel()) ident					(. var label:String = t.val; .)
  ":" Statement0<out body:Statement, scope>		(. statement = SLabel(label, body); .)
| StatementExpression<scope> ';'
.

/*---------------------------------------------------------------------------*/

Block<out statement:Statement, parent:BlockScope>	(. var scope:BlockScope = new BlockScope(parent); .)
= "{" { BlockStatement<scope> } "}"			(. statement = scope.getStatement(); .)
.

/*---------------------------------------------------------------------------*/

BlockStatement<scope:BlockScope>
= IF(isLocalVarDecl(false)) LocalVariableDeclaration<scope> ";"
| ClassOrInterfaceDeclaration<scope>
| Statement0<out statement:Statement, scope>		(. scope.pushStatement(statement); .)
.

/*---------------------------------------------------------------------------*/

LocalVariableDeclaration<scope:BlockScope>
= [ "final" ] Type<out type:DataType> VariableDeclarators  
.

/*---------------------------------------------------------------------------*/

VariableDeclarators
= VariableDeclarator { "," VariableDeclarator }
.

/*---------------------------------------------------------------------------*/

ForInit<scope:BlockScope>
= IF (isLocalVarDecl(true)) LocalVariableDeclaration<scope>
| StatementExpression<scope> MoreStatementExpressions<scope>
.

/*---------------------------------------------------------------------------*/

ForUpdate<scope:BlockScope>
= StatementExpression<scope> MoreStatementExpressions<scope>
.

/*---------------------------------------------------------------------------*/

StatementExpression<scope:BlockScope>
= Expression0<out expression:Expression>		(. checkExprStat(expression);
							   scope.pushStatement(SExpression(expression)); .)
.

/*---------------------------------------------------------------------------*/

MoreStatementExpressions<scope:BlockScope>
= { "," StatementExpression<scope> }
.

/*---------------------------------------------------------------------------*/

Catches<.out catches:Array<Catch>, scope:BlockScope.>	(. catches = []; .)
= CatchClause<out catchBlock:Catch, scope>		(. catches.push(catchBlock); .)
  { CatchClause<out catchBlock:Catch, scope>		(. catches.push(catchBlock); .)
    }
.

/*---------------------------------------------------------------------------*/

CatchClause<out _catch:Catch, scope:BlockScope>
= "catch" "(" FormalParameter0<out parameter:FormalParameter> ")"
  Block<out block:Statement, scope>			(. _catch = {parameter: parameter, body: block}; .)
.

/*---------------------------------------------------------------------------*/

SwitchBlockStatementGroups
= { SwitchBlockStatementGroup }
.

/*---------------------------------------------------------------------------*/

SwitchBlockStatementGroup
= SwitchLabel { BlockStatement<null> }
.

/*---------------------------------------------------------------------------*/

SwitchLabel
= "case" Expression0<out expression:Expression> ':'
| "default" ':'
.

/*---------------------------------------------------------------------------*
 *---------------------------- Expressions ----------------------------------*
 *---------------------------------------------------------------------------*/

Expression0<out expression:Expression>
= Expression1<out expression:Expression>
  {
    AssignmentOperator<out operator:Operator>
    Expression1<out value:Expression>			(.
							// rewrite assignment operators as expressions
							if (operator != null)
								value = EOperation(operator, expression, value);
							// extract reference type
							switch (expression) {
							    case EReference(identifier, base): expression = EAssignment(identifier, base, value);
							    case EArrayAccess(index, base): expression = EArrayAssignment(index, base, value);
							    default: error('invalid assignment left-hand side');
							}
							.)
  }
.

/*---------------------------------------------------------------------------*/

Expression1<out expression:Expression>
= Expression2<out expression:Expression>
  [ ConditionalExpr<out rest:Expression, expression>	(. expression = rest; .)
    ]
.

/*---------------------------------------------------------------------------*/

ConditionalExpr<out expression:Expression, conditional:Expression>
= "?" Expression0<out thenExpression:Expression>
  ":" Expression1<out elseExpression:Expression>	(. expression = EConditional(conditional, thenExpression, elseExpression); .)
.

/*---------------------------------------------------------------------------*/

Expression2<out expression:Expression>
= Expression3<out expression:Expression>
  [ Expression2Rest<out rest:Expression, expression>	(. expression = rest; .)
    ]
.

/*---------------------------------------------------------------------------*/

Expression2Rest<out expression:Expression, operand:Expression>
=							(. var builder = new OperationBuilder(); builder.operand(operand); .)
  Infixop<out operator:Operator>			(. builder.operator(operator); .)
  Expression3<out operand:Expression>			(. builder.operand(operand); .)
  { Infixop<out operator:Operator>			(. builder.operator(operator); .)
    Expression3<out operand:Expression>			(. builder.operand(operand); .)
    }							(. expression = builder.reduce(); .)
| "instanceof" Type<out type:DataType>			(. expression = EInstanceOf(expression, type); .)
.

/*---------------------------------------------------------------------------*/

/*
Expression3<out expression:Expression>               (. var pre:Int = ExprKind.NONE;        .)
= { IF(prefix.get(la.kind) || isTypeCast())
    ( PrefixOp<info>      (. if(pre == ExprKind.NONE) pre = info.getKind(); .)
    | "(" Type ")"                       (. info.setKind(ExprKind.TYPECAST);.)
    )
  }
  Primary<info> { Selector<info> } { PostfixOp<info> }
                            (. if (pre != ExprKind.NONE) info.setKind(pre); .)
.*/

Expression3<out expression:Expression>
= ( Increment<out type:IncrementType>
    Expression3<out rest:Expression>			(. expression = EPrefix(type, rest); .)
    | PrefixOp<out operator:Operator>
      Expression3<out rest:Expression>			(. expression = EOperation(operator, rest); .)
  )
| IF(isTypeCast()) "(" Type<out type:DataType> ")"
  Expression3<out rest:Expression>			(. expression = ECast(type, rest); .)
| Primary<out rest:Expression>				(. expression = rest; .)
  { Selector<out rest:Expression, expression>		(. expression = rest; .)
    }
  { Increment<out type:IncrementType>			(. expression = EPostfix(type, expression); .)
    }
.

/*---------------------------------------------------------------------------*/

Primary<out expression:Expression>	
= "(" Expression0<out rest:Expression> ")" 		(. expression = rest; .)
| "this" ArgumentsOpt<out rest:Expression, EThisReference, null> 		(. expression = rest; .)
| "super" SuperSuffix<out rest:Expression> 		(. expression = rest; .)
| Literal<out rest:Expression> 				(. expression = rest; .)
| "new"	Creator<out rest:Expression> 			(. expression = rest; .)
| ident							(. expression = EReference(t.val); var base:Expression = null; .)
  { IF(dotAndIdent()) '.' ident				(. base = expression; expression = EReference(t.val, expression); .)
    }
  [ IF(isIdentSuffix())IdentifierSuffix<out rest:Expression, expression, base> 	(. expression = rest; .)
    ]
| BasicType<out type:PrimitiveType>
  BracketsOpt '.' "class"				/* (. info.setKind(ExprKind.SELECT);  .) */
| "void" '.' "class"					/* (. info.setKind(ExprKind.SELECT);  .) */
.

/*---------------------------------------------------------------------------*/

Arguments<out arguments:Array<Expression>>		(. arguments = []; .) 
= "(" [ Expression0<out expression:Expression>		(. arguments.push(expression); .)
        { "," Expression0<out expression:Expression> 	(. arguments.push(expression); .)
	  } ] ")"
.

/*---------------------------------------------------------------------------*/

ArgumentsOpt<out expression:Expression, method:Expression, base:Expression>
=							(. expression = method; .)
  [ Arguments<.out arguments:Array<Expression>.>	(. expression = ECall(method, base, arguments); .)
    ]
.

/*---------------------------------------------------------------------------*/

SuperSuffix<out expression:Expression>
= Arguments<.out arguments:Array<Expression>.>		(. expression = ECall(ESuperReference, null, arguments); .)
| '.' ident						(. var method:Expression = EReference(t.val, ESuperReference); .)
  ArgumentsOpt<out expression:Expression, method, ESuperReference>
.

/*---------------------------------------------------------------------------*/

Literal<out expression:Expression>
= intLit						(. expression = EIntegerLiteral(Std.parseInt(t.val)); .)
| floatLit						(. expression = EFloatLiteral(Std.parseFloat(t.val)); .)
| charLit						(. expression = ECharLiteral(t.val.charCodeAt(0)); .)
| stringLit						(. expression = EStringLiteral(t.val); .)
| "true"						(. expression = EBooleanLiteral(true); .)
| "false"						(. expression = EBooleanLiteral(false); .)
| "null"						(. expression = ENull; .)
.

/*---------------------------------------------------------------------------*/

Creator<out expression:Expression>
= BasicType<out type:PrimitiveType>
  ArrayCreatorRest<out expression:Expression, DTPrimitive(type)>
| Qualident<.out qualifier:Array<String>.> 
  ( ArrayCreatorRest<out expression:Expression, DTReference(qualifier)>
  | ClassCreatorRest<out expression:Expression, qualifier>
  )
.

/*---------------------------------------------------------------------------*/

ArrayCreatorRest<out expression:Expression, type:DataType>
= "["
  ( "]" BracketsOpt ArrayInitializer
    | Expression0<out dummy:Expression> "]" 
      { IF (nonEmptyBracket()) "[" Expression0<out dummy:Expression> "]" } 
      { IF (emptyBracket()) "[" "]" }
  )
.

/*---------------------------------------------------------------------------*/

ClassCreatorRest<.out expression:Expression, qualifier:Array<String>.>
= Arguments<.out arguments:Array<Expression>.>		(. expression = EObjectInstantiation(qualifier, arguments); .)
  [ ClassBody<.out definitions:Hash<Definition>.> ]	(. /* TODO */ .)
.

/*---------------------------------------------------------------------------*/

IdentifierSuffix<out expression:Expression, reference:Expression, base:Expression>
= '[' ']' BracketsOpt "." "class"			(. /* info.setKind(ExprKind.SELECT); */ .)
|  Arguments<.out arguments:Array<Expression>.>	(. expression = ECall(reference, base, arguments); .)
|  "." ( "class" | "this" | "super" '.' ident ArgumentsOpt<out dummy:Expression, null, null>)	/*[TODO]*/
.

/*---------------------------------------------------------------------------*/

Selector<out expression:Expression, reference:Expression>
= "." ( ident						(. var base:Expression = reference; reference = EReference(t.val, base); .)
	ArgumentsOpt<out expression:Expression, reference, base>
      | "super" Arguments<.out arguments:Array<Expression>.>
      | "new" InnerCreator
      )
| '[' Expression0<out index:Expression> ']'		(. expression = EArrayAccess(index, reference); .)
.

/*---------------------------------------------------------------------------*/

InnerCreator						(. var qualifier:Array<String> = []; .)
= ident ClassCreatorRest<out expression:Expression, qualifier>
.

/*---------------------------------------------------------------------------*/

ParExpression<out expression:Expression>
= "(" Expression0<out expression:Expression> ")"
.

/*---------------------------------------------------------------------------*/

AssignmentOperator<out operator:Operator>			
= "="						(. operator = null; .)
| "+="						(. operator = OpAdd; .)
| "-="						(. operator = OpSubtract; .)
| "*="						(. operator = OpMultiply; .)
| "/="						(. operator = OpDivide; .)
| "&="						(. operator = OpBitwiseAnd; .)
| "|="						(. operator = OpBitwiseOr; .)
| "^="						(. operator = OpBitwiseXor; .)
| "%="						(. operator = OpModulus; .)
| "<<="						(. operator = OpLeftShift; .)
| ">>="						(. operator = OpRightShift; .)
| ">>>="					(. operator = OpZeroRightShift; .)
.

/*---------------------------------------------------------------------------*/

Infixop<out operator:Operator>
= "||"						(. operator = OpOr; .)
| "&&"						(. operator = OpAnd; .)
| "|"						(. operator = OpBitwiseOr; .)
| "^"						(. operator = OpBitwiseXor; .)
| "&"						(. operator = OpBitwiseAnd; .)
| "=="						(. operator = OpEqual; .)
| "!="						(. operator = OpUnequal; .)
| "<"						(. operator = OpLessThan; .)
| ">"						(. operator = OpGreaterThan; .)
| "<="						(. operator = OpLessThanOrEqual; .)
| ">="						(. operator = OpGreaterThanOrEqual; .)
| "<<"						(. operator = OpLeftShift; .)
| ">>"						(. operator = OpRightShift; .)
| ">>>"						(. operator = OpZeroRightShift; .)
| "+"						(. operator = OpAdd; .)
| "-"						(. operator = OpSubtract; .)
| "*"						(. operator = OpMultiply; .)
| "/"						(. operator = OpDivide; .)
| "%"						(. operator = OpModulus; .)
.

/*---------------------------------------------------------------------------*/

PrefixOp<out operator:Operator>
/*= "++"
| "--"*/
= "!"						(. operator = OpNot; .)
| "~"						(. operator = OpBitwiseNot; .)
| "+"						(. operator = OpUnaryPlus; .)
| "-"						(. operator = OpUnaryMinus; .)
.

/*---------------------------------------------------------------------------*/

Increment<out type:IncrementType>
= "++"						(. type = IIncrement; .)
| "--"						(. type = IDecrement; .)
.

/*---------------------------------------------------------------------------*/
/*
PostfixOp<builder:ExpressionBuilder>
= "++"						(. builder.pushOperator(PPostfix(IIncrement)); .)
| "--"						(. builder.pushOperator(PPostfix(IDecrement)); .)  
.*/

/*---------------------------------------------------------------------------*/

END CompilationUnit.
